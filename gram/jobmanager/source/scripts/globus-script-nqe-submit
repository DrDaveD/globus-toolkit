#! /bin/sh

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh

#
# This script will submit a nqe request and return information to 
# the GRAM job manager about success/failure and status/error code

# The following defaults can be altered by the system administrator.
# These values will be overwritten if the user has specified them in their
# GRAM specification.
#
# Most sites have No_Class defined, at several places it is also used
# (no other class defined).
#------------------------------------------------------------------
default_maxtime=10:00:00
default_notification="never"
default_project=""
#------------------------------------------------------------------

#
################################################
# Site-specific settings
################################################
qsub=${GLOBUS_GRAM_JOB_MANAGER_QSUB-qsub}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
cat=${GLOBUS_SH_CAT-cat}
rm=${GLOBUS_SH_RM-rm}
date=${GLOBUS_SH_DATE-date}
echo=${GLOBUS_SH_ECHO-echo}
################################################

arg_file=$1
# check for the argument file if it does not exist
# then return with an error immediately.
if [ ! -f $arg_file ] ; then
   $echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_BAD_SCRIPT_ARG_FILE
   exit 1
fi
 
# use the argument file to define all the arguments
. $arg_file
 
# if a logfile has been passed in then assume debug mode.
if [ ${grami_logfile} = "/dev/null" ] ; then
    DEBUG_ECHO=:
else
    DEBUG_ECHO=$echo
fi

 
$DEBUG_ECHO "JM_SCRIPT: in nqe">> $grami_logfile

$DEBUG_ECHO ""                                            >> $grami_logfile
$DEBUG_ECHO ============================================  >> $grami_logfile
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
if [ "$DEBUG_ECHO" = "$echo" ] ; then
   $cat $arg_file                                          >> $grami_logfile
fi
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
$DEBUG_ECHO ""                                            >> $grami_logfile

$DEBUG_ECHO "JM_SCRIPT: testing project">> $grami_logfile
if [ -z "${grami_project}" ]; then
   grami_project=${default_project}
fi

$DEBUG_ECHO "JM_SCRIPT: testing class">> $grami_logfile
if [ -z "${grami_class}" ] ; then
   grami_class=${default_class}
fi

$DEBUG_ECHO "JM_SCRIPT: testing notification">> $grami_logfile
if [ -z "${grami_notification}" ] ; then
   grami_notification=${default_notification}
fi

# 4 jobtypes exist               nqe jobtype
# -----------------              -------------------
# jobtype 0 = mpi        ----->  parallel
# jobtype 1 = single     ----->  serial
# jobtype 2 = multiple   ----->  parallel
# jobtype 3 = condor     ----->  ERROR
$DEBUG_ECHO "JM_SCRIPT: testing jobtype" >> $grami_logfile
if [ $grami_job_type = "0" ] ; then
    nqe_jobtype="parallel"
elif [ $grami_job_type = "1" ] ; then
    nqe_jobtype="serial"
elif [ $grami_job_type = "2" ] ; then
    nqe_jobtype="parallel"
elif [ $grami_job_type = "3" ] ; then
   $DEBUG_ECHO "JM_SCRIPT: ERROR: jobtype parameter not supported "
               >> $grami_logfile
   $echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_JOBTYPE_NOT_SUPPORTED"
   exit 1
else
   $DEBUG_ECHO "JM_SCRIPT: invalid jobtype parameter, exiting with 1"
               >> $grami_logfile
   $echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_INVALID_JOBTYPE
   exit 1
fi

$DEBUG_ECHO "JM_SCRIPT: getting environment vars" >> $grami_logfile
#
#loop through all the environment variables.  Variables and values are seperate
#arguments.  While assembling var/value pairs add the specific syntax
#required for this scheduling system (VAR1=VALUE;VAR2=VALUE;)
#
new_grami_env=""
if [ ! -z "${grami_env}" ] ; then
   eval set -- ${grami_env}
   x=0
   while [ "$#" -ne 0 ]; do
       if [ $x = 0 ] ; then
          new_grami_env="${new_grami_env}$1"
          x=1
       else
          x=0
          new_grami_env="${new_grami_env}=$1;"
       fi
       shift
   done
fi
 
createScript () {
   #
   # creates a nqe script.
   #
   $echo "#" 
   $echo "# nqe script, created "`$date` 
   $echo "#" 
   $echo "#QSUB -s @SH@"
   $DEBUG_ECHO "JM_SCRIPT: testing count">> $grami_logfile
   if [ "x${grami_count}" = "x1" ] ; then
    $DEBUG_ECHO "JM_SCRIPT: count is 1, use Cray vector style" >> $grami_logfile
    if [ -z "${grami_max_time}" -o "${grami_max_time}" -eq 0 ]; then
	$echo "# Not maxtime defined, use the defaults one."
    else
	grami_max_time="${grami_max_time}:00"
	$echo "#QSUB -lT ${grami_max_time}"
    fi
   else
    $DEBUG_ECHO "JM_SCRIPT: count is gt 1, use T3E style " >> $grami_logfile
    $echo "#QSUB -l mpp_p=${grami_count}"
    $DEBUG_ECHO "JM_SCRIPT: testing Maxtime">> $grami_logfile
    if [ -z "${grami_max_time}" -o "${grami_max_time}" -eq 0 ]; then
      	$echo "# Not maxtime defined, use the defaults one."
    else
      	grami_max_time="${grami_max_time}:00"
      	$echo "#QSUB -l mpp_t=${grami_max_time}"
    fi
   fi
   $echo "#QSUB -ro"
   $echo "#QSUB -o ${grami_stdout}" 
   $echo "#QSUB -re"
   $echo "#QSUB -e ${grami_stderr}" 
   $echo "#QSUB -J n" 
   if [ -n "${grami_queue}" ] ; then
      $echo "#QSUB -q ${grami_queue}"
   fi
   $echo "cd ${grami_directory}"
   $echo "mpprun -n ${grami_count} ${grami_program} ${grami_args}" 
   $echo "#" 
   $echo "# end command file"
}
 
run_file=${local_tmpdir}/nqe.description.$$
createScript >$run_file

$DEBUG_ECHO "JM_SCRIPT: testing successful creation of the submit"\
            " description file created.">> $grami_logfile
#
#test if the file exists and is writable.
if [ ! -w "${run_file}" ] ; then
   $DEBUG_ECHO "JM_SCRIPT: creation of the submit description file "\
               "${run_file} FAILED" >> $grami_logfile
   $echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_TEMP_SCRIPT_FILE_FAILED"
fi

#
#  grep for the string enclosed in double quotes, which will 
#  contain the ID that the calling program requires in order
#  to cancel the job.
#
#  Note that we get garbage at stderr, so only pipe stdout.
#
out_file=$run_file".out"

#$cat $run_file | $qsub - 1> $out_file
$qsub $run_file 1> $out_file

#the output from the submit command is assumed to look like this:
# "Request <14039.jsimpson>: Submitted to queue <batch> by <username(5835)>."
#
# parse to get "14039.jsimpson"
#
status=`$cat "$out_file" | \
        $grep "Request"   | \
        $awk '{                
                if ( $3 = "Submitted" ) print substr($2, 2, length($2)-3)
             }'`


if test -n "${status}"; then
   $DEBUG_ECHO "JM_SCRIPT: returning job state: "\
               "$GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING" >> $grami_logfile
   $echo "GRAM_SCRIPT_JOB_ID:$status"
   $echo "GRAM_SCRIPT_SUCCESS:$GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING"
else
   $DEBUG_ECHO "##############################" >> $grami_logfile
   $DEBUG_ECHO "JM_SCRIPT: returning script error: "\
          "$GLOBUS_GRAM_PROTOCOL_ERROR_JOB_EXECUTION_FAILED" >> $grami_logfile
   $DEBUG_ECHO "JM_SCRIPT: unknown response from qsub!" >> $grami_logfile
   $DEBUG_ECHO "##############################" >> $grami_logfile
   $echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_JOB_EXECUTION_FAILED"

   echo ""                                                   >> ${grami_stderr}
   echo "-------- output from scheduler submission --------" >> ${grami_stderr}
   cat ${out_file}                                           >> ${grami_stderr}
   echo "--------------------------------------------------" >> ${grami_stderr}
   echo ""                                                   >> ${grami_stderr}

fi

# write the job_id to the argument file.  This is used by any subsequent
# grami_jm_shell routines.  I.E. gram_script_*_poll gram_script_*_rm
$echo "grami_job_id=\"$status\"" >> $arg_file

$rm $run_file $out_file
