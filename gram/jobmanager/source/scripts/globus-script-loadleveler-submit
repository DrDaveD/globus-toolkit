#! /bin/sh -f


. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh

#
# This script will submit a loadleveler request and return information to 
# the GRAM job manager about success/failure and status/error code

# The following defaults can be altered by the system administrator.
# These values will be overwritten if the user has specified them in their
# GRAM specification.
#
# Most sites have No_Class defined, at several places it is also used
# (no other class defined).
#------------------------------------------------------------------
default_maxtime=10:00:00
default_queue=No_Class               # SDSC needs globus_32
default_notification="never"
default_project=""

# Default requirements: Check if environment flags MP_EUILIB/MP_EUIDEVICE
# are set: then choose one of the following settings accordingly.
default_eth_requirements="(Arch== "'"R6000"'") && (Adapter == "'"ethernet"'")" 
default_ip_requirements="(Arch == "'"R6000"'") && (Adapter == "'"hps_ip"'")" 
default_us_requirements="(Arch == "'"R6000"'") && (Adapter == "'"hps_user"'")" 
#------------------------------------------------------------------

#
################################################
# Site-specific settings
################################################
llsubmit=${GLOBUS_GRAM_JOB_MANAGER_LLSUBMIT-llsubmit}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
cat=${GLOBUS_SH_CAT-cat}
sed=${GLOBUS_SH_SED-sed}
rm=${GLOBUS_SH_RM-rm}
date=${GLOBUS_SH_DATE-date}
poe=${GLOBUS_GRAM_JOB_MANAGER_POE-poe}
sh=${GLOBUS_SH-/bin/sh}
################################################

arg_file=$1
# check for the argument file if it does not exist
# then return with an error immediately.
if [ ! -f $arg_file ] ; then
   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_CLIENT_ERROR_BAD_SCRIPT_ARG_FILE
   exit 1
fi
 
# use the argument file to define all the arguments
. $arg_file
 
# if a logfile has been passed in then assume debug mode.
if [ ${grami_logfile} = "/dev/null" ] ; then
    DEBUG_ECHO=:
else
    DEBUG_ECHO=echo
fi

 
$DEBUG_ECHO "JM_SCRIPT: in loadleveler_submit">> $grami_logfile

$DEBUG_ECHO ""                                            >> $grami_logfile
$DEBUG_ECHO ============================================  >> $grami_logfile
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
if [ "$DEBUG_ECHO" = "echo" ] ; then
   cat $arg_file                                          >> $grami_logfile
fi
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
$DEBUG_ECHO ""                                            >> $grami_logfile

$DEBUG_ECHO "JM_SCRIPT: testing maxtime">> $grami_logfile
if [ -z "${grami_max_time}" -o "${grami_max_time}" -eq 0 ]; then
   grami_max_time=${default_maxtime}
else
   grami_max_time=":${grami_max_time}:00"
fi

$DEBUG_ECHO "JM_SCRIPT: testing project">> $grami_logfile
if [ -z "${grami_project}" ]; then
   grami_project=${default_project}
fi

$DEBUG_ECHO "JM_SCRIPT: testing host_count">> $grami_logfile
if [ -z "${grami_host_count}" -o "${grami_host_count}" -eq 0 ]; then
   grami_host_count=""
fi

$DEBUG_ECHO "JM_SCRIPT: testing queue">> $grami_logfile
if [ -z "${grami_queue}" ] ; then
   grami_queue=${default_queue}
fi

$DEBUG_ECHO "JM_SCRIPT: testing notification">> $grami_logfile
if [ -z "${grami_notification}" ] ; then
   grami_notification=${default_notification}
fi

# 4 jobtypes exist               loadleveler jobtype
# -----------------              -------------------
# jobtype 0 = mpi        ----->  parallel
# jobtype 1 = single     ----->  serial
# jobtype 2 = multiple   ----->  parallel
# jobtype 3 = condor     ----->  ERROR
$DEBUG_ECHO "JM_SCRIPT: testing jobtype" >> $grami_logfile
if [ $grami_job_type = "0" ] ; then
    ll_jobtype="parallel"
elif [ $grami_job_type = "1" ] ; then
    ll_jobtype="serial"
elif [ $grami_job_type = "2" ] ; then
    ll_jobtype="parallel"
elif [ $grami_job_type = "3" ] ; then
   $DEBUG_ECHO "JM_SCRIPT: ERROR: jobtype parameter not supported "
               >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_CLIENT_ERROR_JOBTYPE_NOT_SUPPORTED"
   exit 1
else
   $DEBUG_ECHO "JM_SCRIPT: invalid jobtype parameter, exiting with 1"
               >> $grami_logfile
   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_CLIENT_ERROR_INVALID_JOBTYPE
   exit 1
fi

$DEBUG_ECHO "JM_SCRIPT: getting environment vars" >> $grami_logfile
#
#loop through all the environment variables.  Variables and values are seperate
#arguments.  While assembling var/value pairs add the specific syntax
#required for this scheduling system (VAR1=VALUE;VAR2=VALUE;) and check the
#values for MP_EUILIB, MP_EUIDEVICE, and MAUI_COMMENT, if set.
#
euilib=""
euidev=""
pool=""
comment=""
new_grami_env=""
if [ ! -z "${grami_env}" ] ; then
   eval set -- ${grami_env}
   x=0
   while [ "$#" -ne 0 ]; do
       if [ $x = 0 ] ; then
          new_grami_env="${new_grami_env}$1"
	     # there should be an arg $2 according to RSL, but 
	     # unfortunately (a="") is allowed... have to check
	     # the length of $2.
	  if [ "$1" = "MP_EUILIB" -a -n "$2" ]; then
	    euilib=$2
	  elif [ "$1" = "MP_EUIDEVICE" -a -n "$2" ]; then
	    euidev=$2
	  elif [ "$1" = "MP_RMPOOL" -a -n "$2" ]; then
	    pool=$2
	  elif [ "$1" = "MAUI_COMMENT" -a -n "$2" ]; then
	    comment=$2
	  fi
          x=1
       else
          x=0
          new_grami_env="${new_grami_env}=$1;"
       fi
 
       shift
   done
fi
 
$DEBUG_ECHO "JM_SCRIPT: testing requirements" >> $grami_logfile
if [ -z "${grami_requirements}" ] ; then

    # There are three possibilities:
    # euidev == "en0"                    --> ethernet
    # euidev == "css0" && euilib == "ip" --> ip over switch
    # euidev == "css0" && euilib == "us" --> user mode over switch
    # All other settings will default to ip over switch.

    grami_requirements=${default_ip_requirements}
    if [ ! -z "${euilib}" ]; then
	if [ "${euilib}" = "us" ]; then
	    grami_requirements=${default_us_requirements}
	fi
    fi
    if [ ! -z "${euidev}" ]; then
	if [ "${euidev}" = "en0" ]; then
	    grami_requirements=${default_eth_requirements}
        fi
    fi

    if [ ! -z "${pool}" ]; then
       grami_requirements="${grami_requirements} && (Pool == $pool)"
    fi
fi

createScript () {
   #
   # creates a load-leveler script.
   #
   echo "#! $sh -f
   echo "#" 
   echo "# Load-Leveler script, created "`$date` 
   echo "#" 
   echo "#@ initialdir       = ${grami_directory}"
   echo "#@ class            = ${grami_queue}"
   echo "#@ Requirements     = ${grami_requirements}"
   echo "#@ Restart          = no"
   echo "#" 

   if [ -n "${new_grami_env}" ] ; then
      echo "#@ environment      = ${new_grami_env}"
   fi

   echo "#" 
   echo "#@ job_type         = ${ll_jobtype}" 

   if [ -n "${comment}" ]; then
      echo "#@ comment          = ${comment}"
   fi

   if [ "${grami_host_count}" -ne 0 ]; then
      echo "#@ total_tasks      = ${grami_count}"
      echo "#@ node             = ${grami_host_count}"
   else
      echo "#@ min_processors   = ${grami_count}"
      echo "#@ max_processors   = ${grami_count}"
   fi
   #
   #
   echo "#@ wall_clock_limit = ${grami_max_time}"
   echo "#"
   echo "#@ input            = ${grami_stdin}"
   echo "#@ output           = ${grami_stdout}"
   echo "#@ error            = ${grami_stderr}"
   echo "#"
   echo "#@ notification     = ${grami_notification}"
   if [ -n "${grami_project}" ]; then
      echo "#@ account_no       = ${grami_project}"
   fi
   echo "#@ queue" 
   echo "#" 

   if [ $grami_job_type = "0" -o $grami_job_type = "2" ] ; then
        echo "${poe} ${grami_program} ${grami_args}"
   else
        echo "${grami_program} ${grami_args}"
   fi

   echo "#" 
   echo "# end command file"
}
 
run_file=${local_tmpdir}/loadleveler_script.description.$$
createScript >$run_file

$DEBUG_ECHO "JM_SCRIPT: testing successful creation of the submit"\
            " description file created.">> $grami_logfile
#
#test if the file exists and is writable.
if [ ! -w "${run_file}" ] ; then
   $DEBUG_ECHO "JM_SCRIPT: creation of the submit description file "\
               "${run_file} FAILED" >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_CLIENT_ERROR_TEMP_SCRIPT_FILE_FAILED"
fi

#
#  grep for the string enclosed in double quotes, which will 
#  contain the ID that the calling program requires in order
#  to cancel the job.
#
#  Note that we get garbage at stderr, so only pipe stdout.
#
out_file=${run_file}".out"

$llsubmit $run_file 1> $out_file

status=`$cat $out_file | grep "submit:" | $awk '-F"' '{print $2}'`

#
# Remark: ${status} returned here is either the full hostname or the nickname
#         followed by a number ("ico10.322" or "baby005.llnl.gov.431").
#

if test -n "${status}"; then
   $DEBUG_ECHO "JM_SCRIPT: returning job state: "\
               "$GLOBUS_GRAM_CLIENT_JOB_STATE_PENDING" >> $grami_logfile
   echo "GRAM_SCRIPT_JOB_ID:$status"
   echo "GRAM_SCRIPT_SUCCESS:$GLOBUS_GRAM_CLIENT_JOB_STATE_PENDING"
else
   $DEBUG_ECHO "##############################" >> $grami_logfile
   $DEBUG_ECHO "JM_SCRIPT: returning script error: "\
          "$GLOBUS_GRAM_CLIENT_ERROR_JOB_EXECUTION_FAILED" >> $grami_logfile
   $DEBUG_ECHO "JM_SCRIPT: unknown response from llsubmit!" >> $grami_logfile
   $DEBUG_ECHO "##############################" >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_CLIENT_ERROR_JOB_EXECUTION_FAILED"

   echo ""                                                   >> ${grami_stderr}
   echo "-------- output from scheduler submission --------" >> ${grami_stderr}
   cat ${out_file}                                           >> ${grami_stderr}
   echo "--------------------------------------------------" >> ${grami_stderr}
   echo ""                                                   >> ${grami_stderr}

fi

# write the job_id to the argument file.  This is used by any subsequent
# grami_jm_shell routines.  I.E. gram_script_*_poll gram_script_*_rm
echo "grami_job_id=\"$status\"" >> $arg_file

$rm $run_file $out_file
