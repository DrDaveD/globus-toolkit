#! /bin/sh

# Globus Job Manager LSF interface script for submitting a job 

# Author:		Doru Marcusiu (NCSA)
# Last Modified:	6/24/98
#
# This script builds a shell job script which is supplied as input
# to the LSF bsub command. The script is built based on information
# obtained from a file passed as the script's argument. This file
# contains a list of environment variables which are set by way
# of "sourcing" the file from this script. The evironment variables
# set as a result of this action are then used to characterize the
# user's job request. Once the job script has been submitted the
# LSF job id is appended to the file passed as an argument to this
# script to be used by other scripts at a later time.

# The temporary job script is created in a location defined by the
# TMP_DIR and LSF_JOB_SCRIPT name variables. This file is removed at
# the end of this script. 

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh

bsub=${GLOBUS_GRAM_JOB_MANAGER_BSUB-bsub}
bqueues=${GLOBUS_GRAM_JOB_MANAGER_BQUEUES-bqueues}
awk=${GLOBUS_SH_AWK-awk}
mpirun=${GLOBUS_GRAM_JOB_MANAGER_MPIRUN-mpirun}
rm=${GLOBUS_SH_RM-rm}
SH=${GLOBUS_SH-/bin/sh}

#        File name to be used for temporary job script
LSF_JOB_SCRIPT="${local_tmpdir}/lsf_job_script."$$
LSF_JOB_OUT="${LSF_JOB_SCRIPT}.out"
LSF_JOB_ERR="${LSF_JOB_SCRIPT}.err"

arg_file=$1

#        Check for the argument file. If it does not exist
#        then return with an error immediately

if [ ! -f $arg_file ] ; then
   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_BAD_SCRIPT_ARG_FILE
   exit 1
fi
 
#        Source the argument file to set environment variables
#        defining all the job arguments

. $arg_file

#        If a logfile name has been defined then activate debug mode

if [ $grami_logfile = "/dev/null" ] ; then
    DEBUG_ECHO=:
else
    DEBUG_ECHO=echo
fi

$DEBUG_ECHO "JM_SCRIPT: in lsf_submit">> $grami_logfile

$DEBUG_ECHO ""                                            >> $grami_logfile
$DEBUG_ECHO ============================================  >> $grami_logfile
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
if [ "$DEBUG_ECHO" = "echo" ] ; then
   cat $arg_file                                          >> $grami_logfile
fi
$DEBUG_ECHO "JM_SCRIPT: ====argument file contents===="   >> $grami_logfile
$DEBUG_ECHO ""                                            >> $grami_logfile

#        The following several lines of code can be used to perform 2
#        additional error checks prior to job submission. The first check is
#        for the existance of the directory which the user requested
#        be the working directory. If it does not exist the script
#        returns an error and the job is not submitted. The second check
#        is for existance of the file requested by the user to be used for
#        stdin. If the file does not exist the scripts returns an error and
#        the job is not submitted.

#        These checks are only valid if performed on the file system to be used
#        by the host on which the job will run. But, this file system may not
#        be shared with host from which the job is submitted. Therefore, the
#        check does not make sense. If however the host from which the job 
#        will be submitted (i.e. the host running the globus gatekeeper)
#        shares file systems with all the hosts which may potentially
#        run the job these checks can be used. In order to have the job
#        manager perform these checks the following 2 sections of code
#        should *not* be commented out.


#        Check for existance of directory

#$DEBUG_ECHO "JM_SCRIPT: testing for existance of directory $grami_directory" >> $grami_logfile
#if [ -d $grami_directory ]; then
#   $DEBUG_ECHO "JM_SCRIPT: directory $grami_directory found" >> $grami_logfile
#    cd $grami_directory
#else
#   $DEBUG_ECHO "JM_SCRIPT: directory $grami_directory DOES NOT exist; exiting with exit code 1" >> $grami_logfile
#   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_BAD_DIRECTORY
#   exit 1
#fi
#
#         Check for existance of stdin file if not /dev/null
#
#if [ $grami_stdin != "/dev/null" ]; then
#    $DEBUG_ECHO "JM_SCRIPT: testing for existance of stdin file $grami_stdin" >> $grami_logfile
#    if [ -r $grami_stdin ]; then
#        $DEBUG_ECHO "JM_SCRIPT: stdin file $grami_stdin found and is readable" >> $grami_logfile
#    else
#        $DEBUG_ECHO "JM_SCRIPT: stdin file $grami_stdin DOES NOT exist or is not readable; exiting with exit code 1" >> $grami_logfile
#        echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_STDIN_NOT_FOUND
#        exit 1
#    fi
#fi


#	Check for non supported parameters here. That is, if any of the RSL
#	parameters which LSF can not support have been requested return an error.
#	Currently all RSL attributes are supported by LSF

# if (unsupported parameters found)
#     $DEBUG_ECHO "JM_SCRIPT: unsupported parameters found. Exiting with error." >> $grami_logfile
# else
#     $DEBUG_ECHO "JM_SCRIPT: No unsupported parameters found" >> $grami_logfile
# fi
#

$DEBUG_ECHO "JM_SCRIPT: testing for unsupported parameters" >> $grami_logfile
$DEBUG_ECHO "JM_SCRIPT: No unsupported parameters found" >> $grami_logfile

        # Verify existance of queue if queue parameter is not NULL

$DEBUG_ECHO "JM_SCRIPT: testing for queue attribute specification" >> $grami_logfile

if [ ! -z "${grami_queue}" ]; then
    $DEBUG_ECHO "JM_SCRIPT: testing for existance of LSF queue $grami_queue" >> $grami_logfile
    status=`$bqueues $grami_queue`
    if (test "$?" -eq "0") then
        $DEBUG_ECHO "JM_SCRIPT: LSF queue $grami_queue found" >> $grami_logfile
    else
        $DEBUG_ECHO LSF queue [$grami_queue] DOES NOT exist; exiting with exit code 1 >> $grami_logfile
        echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_INVALID_QUEUE
        exit 1
    fi
else
    $DEBUG_ECHO "JM_SCRIPT: no queue attribute specified" >> $grami_logfile
fi

# 4 jobtypes exist               LSF result
# -----------------              ------------------
# jobtype 0 = mpi         -----> run mpirun
# jobtype 1 = single      -----> submit one copy of lsf script
# jobtype 2 = multiple    -----> submit count copy(s) of lsf script
# jobtype 3 = condor      -----> ERROR
$DEBUG_ECHO "JM_SCRIPT: testing jobtype" >> $grami_logfile
if [ $grami_job_type = "0" ] ; then
    lsf_jobtype="mpi"
elif [ $grami_job_type = "1" ] ; then
    lsf_jobtype="single"
elif [ $grami_job_type = "2" ] ; then
    lsf_jobtype="multiple"
elif [ $grami_job_type = "3" ] ; then
   $DEBUG_ECHO "JM_SCRIPT: ERROR: jobtype parameter not supported"
               >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_JOBTYPE_NOT_SUPPORTED"
   exit 1
else
   $DEBUG_ECHO "JM_SCRIPT: invalid jobtype parameter" >> $grami_logfile
   echo GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_INVALID_JOBTYPE
   exit 1
fi

#         Determining cpu time limit

$DEBUG_ECHO "JM_SCRIPT: testing for cpu time limit" >> $grami_logfile
if [ $grami_max_time -eq 0 ] ; then
    cpu_time=0
    $DEBUG_ECHO "JM_SCRIPT: No cpu time specified, using [unlimited] cpu time" >> $grami_logfile
else
    cpu_time=`expr "$grami_max_time" \* "$grami_count"`
    $DEBUG_ECHO "JM_SCRIPT: using $cpu_time minutes for max cpu time" >> $grami_logfile
fi

#       Determining memory limit
#	min memory is *NOT* supported
#       Globus default RSL attribute memory units are in Mbytes
#       LSF default memory attribute units are in Kbytes...
#       so a conversion from Mbytes to Kbytes must be made

Kb=1024

$DEBUG_ECHO "JM_SCRIPT: testing for maximum memory limit" >> $grami_logfile
if [ $grami_max_memory -eq 0 ] ; then
    max_memory=0
    $DEBUG_ECHO "JM_SCRIPT: no maximum memory requested specified" >> $grami_logfile
else
    max_memory=`expr "$grami_max_memory" \* "$Kb"`
    $DEBUG_ECHO "JM_SCRIPT: requested $grami_max_memory Mb for maximum memory" >> $grami_logfile
    $DEBUG_ECHO "JM_SCRIPT: converting Mb to LSF default unit of Kb" >> $grami_logfile
    $DEBUG_ECHO "JM_SCRIPT: using $max_memory Kb for maximum memory" >> $grami_logfile
fi

$DEBUG_ECHO "JM_SCRIPT: testing for minimum memory limit" >> $grami_logfile
if [ $grami_min_memory -eq 0 ] ; then
    $DEBUG_ECHO "JM_SCRIPT: no minimum memory requested specified" >> $grami_logfile
else
    $DEBUG_ECHO "JM_SCRIPT: requested $grami_min_memory Mb for minimum memory" >> $grami_logfile
    $DEBUG_ECHO "JM_SCRIPT: minimum memory request is not supported" >> $grami_logfile
    $DEBUG_ECHO "JM_SCRIPT: minimum memory request is being ignored" >> $grami_logfile
fi

#         Start building job script

$DEBUG_ECHO "JM_SCRIPT: starting to build LSF job script" >> $grami_logfile

echo "# LSF batch job script built by Globus job manager" >> $LSF_JOB_SCRIPT
echo "" >> $LSF_JOB_SCRIPT
echo "" >> $LSF_JOB_SCRIPT

echo "#! ${SH}" >> $LSF_JOB_SCRIPT


if [ ! -z "${grami_queue}" ] ; then
    echo "#BSUB -q $grami_queue" >> $LSF_JOB_SCRIPT
fi

if [ ! -z "${grami_project}" ] ; then
    echo "#BSUB -P $grami_project" >> $LSF_JOB_SCRIPT
fi

if [ $cpu_time -ne 0 ] ; then
    echo "#BSUB -c $cpu_time" >> $LSF_JOB_SCRIPT
fi

if [ $max_memory -ne 0 ] ; then
    echo "#BSUB -M $max_memory" >> $LSF_JOB_SCRIPT
fi


# commented out the "BSUB -o" command because LSF adds additional information
# to the jobs stdout.  Instead redirecting stdout on the command line.
# echo "#BSUB -o $grami_stdout" >> $LSF_JOB_SCRIPT
echo "#BSUB -i $grami_stdin" >> $LSF_JOB_SCRIPT
echo "#BSUB -e $grami_stderr" >> $LSF_JOB_SCRIPT
echo "#BSUB -n $grami_count" >> $LSF_JOB_SCRIPT


# Below is a while loop to reformat the environment variable 
# string to the format needed for the LSF job script. The environment
# variables for the LSF job will be set during the execution
# of the job script. The loop obtains environment variable information
# from the variable $grami_env. The information is then written
# to the LSF job script one line per variable in the form:

# env_variable=env_value; export env_variable

# where...

# env_variable is the name of the environment variable
# env_value is the value of the environment variable

$DEBUG_ECHO "JM_SCRIPT: checking environment" >> $grami_logfile
#
#loop through all the environment variables.  Variables and values are seperate
#arguments.  While assembling var/value pairs add the specific syntax
#required for this scheduling system.
#
new_grami_env=""
 
if [ ! -z "${grami_env}" ] ; then
   eval set -- ${grami_env}
   x=0
   while [ "$#" -ne 0 ]; do
      if [ $x = 0 ] ; then
         save_variable=$1
         x=1
      else
         x=0
         echo "${save_variable}=$1; export ${save_variable}" >> $LSF_JOB_SCRIPT
      fi
 
      shift
   done
fi

new_grami_args=""
if [ ! -z "${grami_args}" ] ; then
   eval set -- ${grami_args}
   new_grami_args="$*"
fi

# Determine directory to be used as working directory 

echo ""  >> $LSF_JOB_SCRIPT
echo "# Changing to directory as requested by user" >> $LSF_JOB_SCRIPT
echo "cd $grami_directory" >> $LSF_JOB_SCRIPT
 
# Determining job request type

echo ""  >> $LSF_JOB_SCRIPT
echo "# Executing job as requested by user" >> $LSF_JOB_SCRIPT
if [ $lsf_jobtype = "mpi" ] ; then
    echo "${mpirun} -np $grami_count $grami_program $new_grami_args > $grami_stdout" >> $LSF_JOB_SCRIPT
elif [ $lsf_jobtype = "multiple" ] ; then
	counter=0
	while (test "$counter" -lt "$grami_count")
	    do
            echo "$grami_program $new_grami_args > $grami_stdout < ${grami_stdin} &" >> $LSF_JOB_SCRIPT
	    counter=`expr $counter + 1`
	    done
        echo "wait" >> $LSF_JOB_SCRIPT;
else
    echo "$grami_program $new_grami_args > $grami_stdout" >> $LSF_JOB_SCRIPT
fi

$DEBUG_ECHO "JM_SCRIPT: LSF job script successfully built" >> $grami_logfile
$DEBUG_ECHO "JM_SCRIPT: submitting LSF job script" >> $grami_logfile

# Execute bsub command

${bsub} < $LSF_JOB_SCRIPT 1>$LSF_JOB_OUT 2>$LSF_JOB_ERR

#old method
#status=`${bsub} < $LSF_JOB_SCRIPT`

if (test "$?" -eq "0") then
   job_id=`cat $LSF_JOB_OUT | ${awk} '{sub(/</,"",$2);sub(/>/,"",$2);print $2}'`

   if [ "${job_id}" = "" ] ; then
      $DEBUG_ECHO "job *NOT* submitted successfully!" >> $grami_logfile
      $DEBUG_ECHO "failed getting the pbs jobid for the job!" >> $grami_logfile
      echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_GETTING_JOBID"
   else
      echo "grami_job_id=${job_id}" >> $arg_file
      $DEBUG_ECHO "JM_SCRIPT: job submitted successfully!" >> $grami_logfile
      $DEBUG_ECHO "JM_SCRIPT: returning job state: $GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING" >> $grami_logfile
      echo "GRAM_SCRIPT_JOB_ID:$job_id"
      echo "GRAM_SCRIPT_SUCCESS:$GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING"
      # Remove temporary job script file
      ${rm} $LSF_JOB_SCRIPT $LSF_JOB_OUT $LSF_JOB_ERR
      $DEBUG_ECHO "JM_SCRIPT: exiting gram_script_lsf_submit\n\n" >> $grami_logfile
      exit
   fi
else
   $DEBUG_ECHO "JM_SCRIPT: job *NOT* submitted successfully!" >> $grami_logfile
   echo "GRAM_SCRIPT_ERROR:$GLOBUS_GRAM_PROTOCOL_ERROR_JOB_EXECUTION_FAILED"
fi

# We got problems if we get this far

echo ""                                                   >> ${grami_stderr}
echo "-------- output from scheduler submission --------" >> ${grami_stderr}
cat ${LSF_JOB_ERR}                                        >> ${grami_stderr}
echo "--------------------------------------------------" >> ${grami_stderr}
echo ""                                                   >> ${grami_stderr}

# Remove temporary job script file
${rm} $LSF_JOB_SCRIPT $LSF_JOB_OUT $LSF_JOB_ERR

$DEBUG_ECHO "JM_SCRIPT: exiting gram_script_lsf_submit" >> $grami_logfile
$DEBUG_ECHO "" >> $grami_logfile
$DEBUG_ECHO "" >> $grami_logfile

exit 1
