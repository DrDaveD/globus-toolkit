/**
@mainpage

<h1>Introduction</h1>
A job manager service is configured to handle
job requests for a single architecture, using a single scheduler. The
scheduler may be a simple "fork" scheduler (built in to the job manager),
or some other local job management system. The job manager interfaces with
these systems using a set of scheduler-specific scripts. This page describes
the naming conventions and parameter passing conventions use by the job
manager to submit, query, cancel, and signal a job through a scheduler
interface.

Each scheduler is identified by a scheduler type, which can consist of
alphanumeric characters. The job manager program is passed the scheduler
type through it's command line parameters (typically through it's grid-services
configuration file). The names of the scripts use to handle job requests are
constructed by the job manager using the scheduler type, the location of the
script directory (usually $GLOBUS_LOCATION/libexec) and the operation
to be done. There are four scripts which each scheduler should implement:

<dl>
<dt>globus-script-<em>type</em>-submit</dt>
<dd>
This script submits a job request to the scheduler. It is given as input
an arguments file, which contains a scheduler-independent job description.
The script is expected output either a job ID and a job state, or a GRAM
error code.
</dd>
<dt>globus-script-<em>type</em>-poll</dt>
<dd>
This script polls the scheduler to determine the current job state. It is given
as input an arguments file which contains the job ID returned from the 
<em>submit</em> script. The script is expected to query the scheduler for the
job state, and then either output the status, or an error code.
</dd>
<dt>globus-script-<em>type</em>-rm</dt>
<dd>
This script requests the scheduler to cancel the job. The script is given
as input an arguments file which contains the job ID returned from the
<em>submit</em> script. The script is expected to output either
a success or a failure value.
</dd>
<dt>globus-script-<em>type</em>-signal [optional]</dt>
<dd>
This script sends a signal to the scheduler. The script is given as input
an arguments file which contains the job ID returned from the 
<em>submit</em> script and a signal file which defines the signal to be
sent to the scheduler. The script is expected to output either a
success or failure value.
</dd>
</dl>

<h1>Input Files</h1>

<h2>The Args File</h2>
As mentioned in the brief descriptions above, each of the scripts receives
an argument file as input. The argument file is a bourne-shell compatible
script which defines a number shell variables containing information about
the job request. The name of the file is passed as the first argument
("$1" in shell) to the script. It is intended to be sourced 
by the script. The following variables are defined in the args file:

<dl>
<dt>grami_logfile</dt>
<dd>The name of a file which the script should send any logging
    information.</dd>
<dt>grami_directory</dt>
<dd>The directory which the job should be started in.</dd>
<dt>grami_program</dt>
<dd>The name of the executable to run.</dd>
<dt>grami_args</dt>
<dd>A @ref globus_gram_job_manager_shell_list "shell list" of parameters
to the executable.</dd>
<dt>grami_env</dt>
<dd>A @ref globus_gram_job_manager_shell_list "shell list" of 
variables to set in the job's environment.</dd>
<dt>grami_count</dt>
<dd>The number of instances of the executable to run.</dd>
<dt>grami_stdin</dt>
<dd>The name of a file which contains the "standard input" which should be
fed into the job.</dd>
<dt>grami_stdout</dt>
<dd>The name of a file into which the job should write it's output.</dd>
<dt>grami_stderr</dt>
<dd>The name of a file into which the job should write it's standard error
data.</dd>
<dt>grami_max_wall_time</dt>
<dd>The maximum wallclock time for which the job should be scheduled.</dd>
<dt>grami_max_cpu_time</dt>
<dd>The maximum CPU time for which the job should be scheduled.</dd>
<dt>grami_max_time</dt>
<dd>The maximum time (CPU and wallclock) for which the job should be
scheduled.</dd>
<dt>grami_start_time</dt>
<dd>???</dd>
<dt>grami_min_memory</dt>
<dd>The minimum amount of memory required to run this job.</dd>
<dt>grami_max_memory</dt>
<dd>The maximum amount of memory required to run this job.</dd>
<dt>grami_host_count</dt>
<dd>The number of host nodes to distribute the <em>grami_count</em> instances
of the executable over (for SMP cluster schedulers).</dd>
<dt>grami_job_type</dt>
<dd>The startup method for this job. It may be
GLOBUS_GRAM_PROTOCOL_JOBTYPE_SINGLE (start only one process, despite the
grami_count), GLOBUS_GRAM_PROTOCOL_JOBTYPE_MULTIPLE (start grami_count number
of processes or threads), GLOBUS_GRAM_PROTOCOL_JOBTYPE_MPI (use the appropriate
MPI startup method for this scheduler), or GLOBUS_GRAM_PROTOCOL_JOBTYPE_CONDOR
(start the job in the "condor universe").
</dd>
<dt>grami_queue</dt>
<dd>The job queue or class to which the job should be submitted.</dd>
<dt>grami_project</dt>
<dd>The project or account to which the job should be charged.</dd>
<dt>grami_reservation_handle</dt>
<dd>???</dd>
<dt>grami_uniq_id</dt>
<dd>???</dd>
<dt>grami_condor_arch</dt>
<dd>The condor architecture to which the job should be submitted. (condor
only)</dd>
<dt>grami_condor_os</dt>
<dd>The condor operating system to which the job should be submitted. (condor
only)</dd>
<dt>KRB5CCNAME</dt>
<dd>???</dd>
<dt>grami_job_id</dt>
<dd>The unique job ID. This is only set in the arguments file after the submit
script has been successfully called.</dd>
</dl>

<h2>The Signal File</h2>
As mentioned in the brief descriptions above, the signal script receives
an extra file as input containing signal information.
The signal file is also a bourne-shell compatible
script. It defines a number of shell variables containing information about
the signal request. The name of the file is passed as the second argument
("$2" in shell) to the script. It is intended to be sourced 
by the script. The following variables are defined in the signal file:

<dl>
<dt>grami_signal</dt>
<dd>The integer signal code</dd>
<dt>grami_signal_arg</dt>
<dd>The signal-specific arguments. The signals values are defined
in the @ref globus_gram_protocol_constants documentation.</dd>
</dl>

<h1>GRAM Constants</h1>
To assist in writing GRAM scripts, the
<code>globus-gram-protocol-constants.sh</code> script
is available in the Globus libexecdir. This script defines shell variables for
all of the GRAM error codes, job states, and signals. These variables have
the same names as the enumeration values defined in
@ref globus_gram_protocol_constants.

<em>should add job type enums to this?</em>

@anchor globus_gram_job_manager_shell_list 
<h1>Appendix: Shell Lists</h1>
As the Bourne shell does not have a portable syntax for arrays or lists,
we use the following convention to pass multi-value parameters from the
job manager to the scripts. Each variable which is defined as a shell
list above, has a value which is a single-quoted string containing
space-delimited double-quoted values. This format was chosen so that the
script can use the "eval set --" syntax to iterate over the values in the
list without losing embedded shell metacharacters.

As an example, the following script fragment sets the environment values
defined in the grami_env list in the current shell environment:

@code
if [ -n "$grami_env" ]; then
    eval set -- "$grami_env"
    while [ "$#" -ne 0 ]; do
	variable="$1"
	value="$2"
	shift
	shift
	eval $variable='$value'
    done
fi
@endcode


*/
