
# Globus::GRAM::JobManager::fork package
#
# CVS Information:
# $Source$
# $Date$
# $Revision$
# $Author$

use Globus::GRAM::Error;
use Globus::GRAM::JobState;
use Globus::GRAM::JobManager;
use Globus::GRAM::StdioMerger;
use Globus::Core::Paths;

use IO::Pipe;
use Fcntl;
use Config;

package Globus::GRAM::JobManager::fork;

@ISA = qw(Globus::GRAM::JobManager);

my ($mpirun);

BEGIN
{
    $mpirun = '@MPIRUN@';
}

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my $description = $self->{JobDescription};
    my $tag = $description->cache_tag() or $ENV{GLOBUS_GRAM_JOB_CONTACT};
    my $stdout = $description->stdout();
    my $stderr = $description->stderr();

    if($description->jobtype() eq 'multiple' && $description->count > 1)
    {
	$self->{STDIO_MERGER} =
	    new Globus::GRAM::StdioMerger($tag, $stdout, $stderr);
    }
    else
    {
	$self->{STDIO_MERGER} = 0;
    }

    return $self;
}

sub submit
{
    my $self = shift;
    my $cmd;
    my $pid;
    my @job_id;
    my $count;
    my $multi_output = 0;
    my $description = $self->{JobDescription};
    my $pipe;
    my @cmdline;
    my @environment;
    my @library_path;
    my @arguments;
    
    if(!defined($description->directory()))
    {
        return Globus::GRAM::Error::RSL_DIRECTORY;
    }
    chdir $description->directory() or
        return Globus::GRAM::Error::BAD_DIRECTORY;

    @environment = $description->environment();
    foreach $tuple ($description->environment())
    {
	if(!ref($tuple) || scalar(@$tuple) != 2)
	{
	    return Globus::GRAM::Error::RSL_ENVIRONMENT();
	}
	$CHILD_ENV{$tuple->[0]} = $tuple->[1];
    }

    @library_path = $description->library_path();
    foreach (@library_path)
    {
	if(ref($_))
	{
	    return Globus::GRAM::Error::RSL_LIBRARY_PATH();
	}
	$self->append_path(\%CHILD_ENV, 'LD_LIBRARY_PATH', $_);
	if($Config{osname} eq 'irix')
	{
	    $self->append_path(\%CHILD_ENV, 'LD_LIBRARYN32_PATH', $_);
	    $self->append_path(\%CHILD_ENV, 'LD_LIBRARY64_PATH', $_);
	}
    }

    if(ref($description->count()) ||
       $description->count() != int($description->count()))
    {
	return Globus::GRAM::Error::INVALID_COUNT();
    }
    if($description->jobtype() eq 'multiple')
    {
	$count = $description->count();
	$multi_output = 1 if $count > 1;
    }
    elsif($description->jobtype() eq 'single')
    {
	$count = 1;
    }
    elsif($description->jobtype() eq 'mpi' && $mpirun ne 'no')
    {
	$count = 1;
	@cmdline = ($mpirun, '-np', $description->count());
    }
    else
    {
        return Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED();
    }
    if( $description->executable eq "")
    {
	return Globus::GRAM::Error::RSL_EXECUTABLE();
    }
    elsif(! -f $description->executable())
    {
	return Globus::GRAM::Error::EXECUTABLE_NOT_FOUND();
    }
    elsif(! -x $description->executable())
    {
	return Globus::GRAM::Error::EXECUTABLE_PERMISSIONS();
    }
    elsif( $description->stdin() eq "")
    {
	return Globus::GRAM::Error::RSL_STDIN;
    }
    elsif(! -r $description->stdin())
    {
	return Globus::GRAM::Error::STDIN_NOT_FOUND();
    }

    push(@cmdline, $description->executable());

    @arguments = $description->arguments();
    foreach(@arguments)
    {
	if(ref($_))
	{
	    return Globus::GRAM::Error::RSL_ARGUMENTS;
	}
    }
    if(defined($arguments[0]))
    {
	push(@cmdline, @arguments);
    }

    for(my $i = 0; $i < $count; $i++)
    {
	if($multi_output)
	{
	    $job_stdout = $self->{STDIO_MERGER}->add_file('out');
	    $job_stderr = $self->{STDIO_MERGER}->add_file('err');
	}
	else
	{
	    $job_stdout = $description->stdout();
	    $job_stderr = $description->stderr();
	}

        # should close on exec
        $pipe = new IO::Pipe;
	$pid = fork();

	if($pid == 0)
	{
	    $pipe->writer();

            # forked child
	    %ENV = %CHILD_ENV;

	    close(STDIN);
	    close(STDOUT);
	    close(STDERR);

	    open(STDIN, "<" . $description->stdin());
	    open(STDOUT, ">>$job_stdout");
	    open(STDERR, ">>$job_stderr");
	    
	    exec (@cmdline);
	    $pipe->print('X');
	    $pipe->close();
	    exit(1);
	}
	else
	{
	    $pipe->reader();
	    $_ = <$pipe>;
	    $pipe->close();

	    if($_ eq 'X')
	    {
		# exec failed. kill rest of job and return an error
		foreach(@job_id)
		{
		    kill(SIGTERM, $_);

		    sleep(5);
		    
		    kill(SIGKILL, $_);
		}
		return Globus::GRAM::Error::JOB_EXECUTION_FAILED;
	    }
	    push(@job_id, $pid);
	}
    }
    $merge_file->close() if defined($merge_file);

    $description->add('jobid', join(',', @job_id));
    return { JOB_STATE => Globus::GRAM::JobState::ACTIVE,
	     JOB_ID => join(',', @job_id) };
}

sub poll
{
    my $self = shift;
    my $description = $self->{JobDescription};
    my $state;

    $self->log("polling job " . $description->jobid());
    $_ = kill(0, split(/,/, $description->jobid()));

    if($_ > 0)
    {
	$state = Globus::GRAM::JobState::ACTIVE;
    }
    else
    {
	$state = Globus::GRAM::JobState::DONE;
    }
    if($self->{STDIO_MERGER})
    {
	$self->{STDIO_MERGER}->poll($state == Globus::GRAM::JobState::DONE);
    }

    return { JOB_STATE => $state };
}

sub cancel
{
    my $self = shift;
    my $description = $self->{JobDescription};

    $self->log("cancel job " . $description->jobid());

    kill(SIGTERM, split(/,/, $description->jobid()));

    sleep(5);
    
    kill(SIGKILL, split(/,/, $description->jobid()));

    return { JOB_STATE => Globus::GRAM::JobState::FAILED };
}

1;
