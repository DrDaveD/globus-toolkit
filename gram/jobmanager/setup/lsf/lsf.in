use Globus::GRAM::Error;
use Globus::GRAM::JobState;
use Globus::GRAM::JobManager;
use Globus::Core::Paths;

use POSIX;
use Config;

package Globus::GRAM::JobManager::lsf;

@ISA = qw(Globus::GRAM::JobManager);

my ($mpirun, $bsub, $bjobs, $bkill);

BEGIN
{
    $mpirun = '@MPIRUN@';
    $bsub   = '@BSUB@';
    $bjobs  = '@BJOBS@';
    $bkill  = '@BKILL@';
}

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    
    bless $self, $class;
    return $self;
}

sub submit
{
    my $self = shift;
    my $description = $self->{JobDescription};
    my $tag = $description->cache_tag() or $ENV{GLOBUS_GRAM_JOB_CONTACT};
    my $status;
    my $lsf_job_script;
    my $lsf_job_script_name;
    my $errfile = "";
    my $queue;
    my $job_id;
    my $script_url;
    my @arguments;
    my $email_when = "";
    my $library_path;
    my @library_vars;

    $self->log("Entering lsf submit");

    # check jobtype
    if(defined($description->jobtype()))
    {
	if($description->jobtype !~ /^(mpi|single|multiple)$/)
	{
	    return Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED;
	}
	elsif($description->jobtype() eq 'mpi' && $mpirun eq "no")
	{
	    return Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED;
	}
    }
    if( $description->directory eq '')
    {
	return Globus::GRAM::Error::RSL_DIRECTORY;
    }
    if((! -d $description->directory) || (! -r $description->directory))
    {
	return Globus::GRAM::Error::BAD_DIRECTORY;
    }
    if( $description->executable eq "")
    {
	return Globus::GRAM::Error::RSL_EXECUTABLE();
    }
    elsif(! -f $description->executable())
    {
	return Globus::GRAM::Error::EXECUTABLE_NOT_FOUND();
    }
    elsif(! -x $description->executable())
    {
	return Globus::GRAM::Error::EXECUTABLE_PERMISSIONS();
    }
    elsif( $description->stdin() eq "")
    {
	return Globus::GRAM::Error::RSL_STDIN;
    }
    elsif(! -r $description->stdin())
    {
       return Globus::GRAM::Error::STDIN_NOT_FOUND();
   }


    $self->log("Determining job max time cpu from job description");
    if(defined($description->max_cpu_time())) 
    {
	$cpu_time = $description->max_cpu_time();
	$self->log("   using maxcputime of $cpu_time");
    }
    elsif(defined($description->max_time()))
    {
	$cpu_time = $description->max_time();
	$self->log("   using maxtime of $cpu_time");
    }
    else
    {
	$cpu_time = 0;
	$self->log('   using queue default');
    }

    $self->log("Determining job max wall time limit from job description");
    if(defined($description->max_wall_time()))
    {
	$wall_time = $description->max_wall_time();
	$self->log("    using maxwalltime of $wall_time");
    }
    else
    {
	$wall_time = 0;
	$self->log("    using queue default");
    }

    if($description->queue() ne '')
    {
	$queue = $description->queue();
    }

    $self->log('Building job script');

    $script_url = "$tag/lsf_job_script.$$"; 
    system("globus-gass-cache -add -t $tag -n $script_url file:/dev/null");
    $lsf_job_script_name = `globus-gass-cache -query $script_url`;
    chomp($lsf_job_script_name);
    if($lsf_job_script_name eq "")
    {
	return GLOBUS_GRAM_PROTOCOL_ERROR_TEMP_SCRIPT_FILE_FAILED();
    }

    $lsf_job_script = new IO::File($lsf_job_script_name, '>');

    $lsf_job_script->print(<<EOF);
#! /bin/sh
#
# LSF batch job script built by Globus Job Manager
#
EOF

    if(defined($queue))
    {
	$lsf_job_script->print("#BSUB -q $queue\n");
    }
    if(defined($description->project()))
    {
	$lsf_job_script->print("#BSUB -P " . $description->project() . "\n");
    }

    if($cpu_time != 0)
    {
	if($description->jobtype() eq 'multiple')
	{
	    $total_cpu_time = $cpu_time * $description->count();
	}
	else
	{
	    $total_cpu_time = $cpu_time;
	}
	$lsf_job_script->print("#BSUB -c ${cpu_time}\n");
    }

    if($wall_time != 0)
    {
	$lsf_job_script->print("#BSUB -W $wall_time\n");
    }

    if($description->max_memory() != 0)
    {
	$max_memory = $description->max_memory() * 1024;

	$lsf_job_script->print("#BSUB -M $max_memory\n");
    }
    $lsf_job_script->print("#BSUB -i " . $description->stdin() . "\n");
    $lsf_job_script->print("#BSUB -e " . $description->stderr() . "\n");
    $lsf_job_script->print("#BSUB -o " . $description->stdout() . "\n");
    $lsf_job_script->print("#BSUB -N\n");
    $lsf_job_script->print("#BSUB -n " . $description->count() . "\n");

    foreach my $tuple ($description->environment())
    {
	if(!ref($tuple) || scalar(@$tuple) != 2)
	{
	    return Globus::GRAM::Error::RSL_ENVIRONMENT();
	}
	$lsf_job_script->print($tuple->[0] . "=" . $tuple->[1]
	                       . "; export " . $tuple->[0] . "\n");
    }

    $library_path = join(':', $description->library_path());
    @library_vars = ('LD_LIBRARY_PATH');

    if($Config{osname} eq 'irix')
    {
	push(@library_vars, 'LD_LIBRARYN32_PATH', 'LD_LIBRARY64_PATH');
    }

    foreach (@library_vars)
    {
	$lsf_job_script->print(<<EOF);

	if test 'X\${$_}' != 'X'; then
	    $_="\${LD_LIBRARY_PATH}:$library_path"
	else
	    $_="$library_path"
	fi
	export $_
EOF

    $lsf_job_script->print("\n#Change to directory requested by user\n");
    $lsf_job_script->print('cd ' . $description->directory() . "\n");

    @arguments = $description->arguments();

    foreach(@arguments)
    {
        if(ref($_))
	{
	    return Globus::GRAM::Error::RSL_ARGUMENTS;
	}
    }
    if($arguments[0])
    {
        foreach(@arguments)
        {
             $_ =~ s/\\/\\\\/g;
	     $_ =~ s/\$/\\\$/g;
	     $_ =~ s/"/\\\"/g;
	     $_ =~ s/`/\\\`/g;
	     
	     $args .= '"' . $_ . '" ';
        }
    }
    else
    {
	$args = "";
    }
    if($description->jobtype() eq "mpi")
    {
	$lsf_job_script->print("$mpirun -np " . $description->count() . " ");

	$lsf_job_script->print($description->executable()
	                       . " $args \n");
    }
    elsif($description->jobtype() eq 'multiple')
    {
	for(my $i = 0; $i < $description->count(); $i++)
	{
	    $lsf_job_script->print($description->executable() . " $args &\n");
	}
	$lsf_job_script->print("wait\n");
    }
    else
    {
	$lsf_job_script->print($description->executable() . " $args\n");
    }
    $lsf_job_script->close();
    chmod 0755, $lsf_job_script_name;

    if($description->logfile() ne "")
    {
        $errfile = "2>" . $description->logfile();
    }

    $job_id = (grep(/is submitted/,
                   split(/\n/, `$bsub < $lsf_job_script_name $errfile`)))[0];

    if($? == 0)
    {
	$job_id =~ m/<([^>]*)>/;
	$job_id = $1;

	return {JOB_ID => $job_id};
    }
    system("globus-gass-cache -cleanup-url $tag/lsf_job_script.$$");

    return Globus::GRAM::Error::INVALID_SCRIPT_REPLY;
}

sub poll
{
    # The LSF bjobs command is used to obtain the current
    # status of the job. This status is then returned.
    #
    # The Status field can contain one of the following strings:
    #
    # string        stands for                      Globus context meaning
    # --------------------------------------------------------------------
    # RUN           Running                         ACTIVE
    # PEND          Wating to be scheduled          PENDING
    # USUSP         Suspended while running         SUSPENDED
    # PSUSP         Suspended while pending         SUSPENDED
    # SSUSP         Suspended by system             SUSPENDED
    # DONE          Completed sucessfully           DONE
    # EXIT          Completed unsuccessfully        FAILED
    # UNKWN         Unknown state                   FAILED
    # ZOMBI         Unknown state                   FAILED

    my $self = shift;
    my $description = $self->{JobDescription};
    my $job_id = $description->jobid();
    my $state;
    my $status_line;

    $self->log("polling job $job_id");

    # Get first line matching job id
    $_ = (grep(/$job_id/, `$bjobs $job_id 2>/dev/null`))[0];

    # Get 3th field (status)
    $_ = (split(/\s+/))[2];

    if(/PEND/)
    {
	$state = Globus::GRAM::JobState::PENDING;
    }
    elsif(/USUSP|SSUSP|PSUSP/)
    {
	$state = Globus::GRAM::JobState::SUSPENDED
    }
    elsif(/RUN/)
    {
	$state = Globus::GRAM::JobState::ACTIVE;
    }
    elsif(/UNKWN|ZOMBI/)
    {
	$state = Globus::GRAM::JobState::FAILED;
    }
    else
    {
	$state = Globus::GRAM::JobState::DONE;
    }

    return {JOB_STATE => $state};
}

sub cancel
{
    my $self = shift;
    my $description = $self->{JobDescription};
    my $job_id = $description->jobid();

    $self->log("cancel job $job_id");

    system("$bkill $job_id >/dev/null 2>/dev/null");

    return {};
}

1;
