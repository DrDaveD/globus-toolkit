#! /bin/sh -f
###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
# string        stands for                      Globus context meaning
# --------------------------------------------------------------------
# RUN           Running                         ACTIVE
# PEND          Wating to be scheduled          PENDING
# USUSP         Suspended while running         SUSPENDED
# PSUSP         Suspended while pending         SUSPENDED
# SSUSP         Suspended by system             SUSPENDED
# DONE          Completed sucessfully           DONE
# EXIT          Completed unsuccessfully        FAILED
# UNKWN         Unknown state                   FAILED
# ZOMBI         Unknown state                   FAILED
########

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh


# programs used in this script located by autoconf:
qstat=${GLOBUS_GRAM_JOB_MANAGER_QSTAT-qstat}
qhost=${GLOBUS_GRAM_JOB_MANAGER_QHOST-qhost}
qconf=${GLOBUS_GRAM_JOB_MANAGER_QCONF-qconf}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
sed=${GLOBUS_SH_SED-sed}
expr=${GLOBUS_SH_EXPR-expr}
tmp_file="${local_tmpdir}/globus_tmp_file.$$"


############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#
# Some comments about how TOTALNODES and FREENODES is obtained:
#
#
# TOTALNODES:
# The qhost command is used to obtain information about all
# the hosts known to GRD. The header lines are removed and 
# information about the number of cpus and the load is gathered.
#
# FREENODES:
# The number of free nodes is calculated by subtracting the total
# load from the total number of CPUs.
#

GetNodeCount() {
   if (test ! -x "${qhost}"); then
      echo "cannot find one of the GRD needed commands" \
           "to determine load/node information!"
      echo "setting free nodes to zero."
      FREENODES=0
   else
      set -- `${qhost} ${qopt} | ${grep} -v HOSTNAME \
                               | ${grep} -v -- '--------' \
                               | ${awk} '{if ($4 != "-") nodes += $3; if ($4 != "-") load += $4>$3 ? $3 : $4 } END {print nodes, int(load+.5)}'`
      TOTALNODES=$1
      LOAD=$2
      FREENODES=`${expr} $TOTALNODES - $LOAD`
   fi
}



############################################################
#
# OutputJobEntry
#
#
# convert scheduler specific information to the standard GRAM queue
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <Job Entry Value>
#

OutputJobEntry() {

   echo "GRAM_SCRIPT_QE:startqueueentry"
   echo "GRAM_SCRIPT_QE:localjobid ${localjobid}"
   echo "GRAM_SCRIPT_QE:localusername ${localusername}"
#   echo "GRAM_SCRIPT_QE:count ${count}"
   echo "GRAM_SCRIPT_QE:status ${status}"
   echo "GRAM_SCRIPT_QE:queueName ${queueName}"
   echo "GRAM_SCRIPT_QE:endqueueentry"
}


############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue
# parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <Queue Value>

OutputQueueEntry() {
   echo "GRAM_SCRIPT_Q:StartQueue"
   echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
   echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
   echo "GRAM_SCRIPT_Q:queueName ${queueName}"
   echo "GRAM_SCRIPT_Q:maxtime ${maxtime}"
   echo "GRAM_SCRIPT_Q:maxCPUtime ${maxCPUtime}"
   echo "GRAM_SCRIPT_Q:maxCount ${maxCount}"
   echo "GRAM_SCRIPT_Q:maxRunningJobs ${maxRunningJobs}"
   echo "GRAM_SCRIPT_Q:maxJobsInQueue ${maxJobsInQueue}"
   echo "GRAM_SCRIPT_Q:maxTotalMemory ${maxTotalMemory}"
   echo "GRAM_SCRIPT_Q:maxSingleMemory ${maxSingleMemory}"
   echo "GRAM_SCRIPT_Q:whenActive 0"
   echo "GRAM_SCRIPT_Q:status ${status}"
   echo "GRAM_SCRIPT_Q:dispatchType batch"
   echo "GRAM_SCRIPT_Q:priority ${priority}"
#   echo "GRAM_SCRIPT_Q:jobWait 0"
#   echo "GRAM_SCRIPT_Q:schedulerSpecific"
   echo "GRAM_SCRIPT_Q:notlistingjobentries"
   echo "GRAM_SCRIPT_Q:EndQueue"
}


################## main section #######################

#assumption is that the qstat path will take the form
# /<dir>/<dir>.../<grd_root>/bin/<grd_arch>/qstat
# so parse the command from the end to get the GRD ROOT dir.
#
# from the qsub path, remove the last slash and all that follows it.
# Leaving the directory.  Not all systems have dirname.
grd_dir=`echo $qstat | $sed 's|/[^/][^/]*$||'`

# remove everything up to the last slash.  Leaving the grd arch value.
GRD_ARCH=`echo $grd_dir | $sed 's|.*/||'`

#remove the next 2 subdir (e.g. <bin>/<arch>) leaving the grd_root
grd_dir=`echo $grd_dir | $sed 's|/[^/][^/]*$||'`
GRD_ROOT=`echo $grd_dir | $sed 's|/[^/][^/]*$||'`
export GRD_ROOT
. $GRD_ROOT/default/common/settings.sh


# if GRD_ARCH is set, only get information for one architecture

if [ -n "$GRD_ARCH" ]; then
   qopt="-l arch=$GRD_ARCH"
else
   qopt=
fi

# Output Node information
# Ouput queue values where possible

GetNodeCount

#
# Obtain and output queue and job information
# loop through all queues and report queue information and information
# about each job in that queue. 
#
# Must use shift since accessible number of positional parameters is limited
# to less than 9.


# Collect job information into file for later processing


${qstat} | ${grep} -v "job-ID" | \
           ${grep} -v -- "---------" | \
           ${grep} -v "^				 " > "${tmp_file}"


# Collect queue information 

${qstat} -f ${qopt} | ${grep} -v queuename | \
                      ${grep} -v -- "--------" | \
                      ${grep} -v "^ " | while read entry ; do


    if [ $? != 0 ] ; then
       break
    fi
 
    if echo "${entry}" | ${grep} "#########" >/dev/null 2>&1 ; then
       break
    fi

    set -- ${entry}

    priority=0
    queueName=$1
    status=$6
    maxJobsInQueue="unlimited"
    maxRunningJobs=`${expr} $3 : ".*\/\(.*\)"`
    qout=`${qconf} -sq $queueName`
    maxCount=`echo "$qout" | ${grep} "^slots" | \
              ${awk} '{ if ($2 == "INFINITY") print "0"; else print $2 }'`
    maxtime=`echo "$qout" | ${grep} "^h_rt" | \
              ${awk} '{ if ($2 == "INFINITY") print "0"; else print $2 }'`
    maxCPUtime=`echo "$qout" | ${grep} "^h_cpu" | \
              ${awk} '{ if ($2 == "INFINITY") print "0"; else print $2 }'`
    maxSingleMemory=`echo "$qout" | ${grep} "^h_data" | \
              ${awk} '{ if ($2 == "INFINITY") print "0"; else print $2 }'`
    maxTotalMemory=0


    OutputQueueEntry


# obtain information about jobs in this queue 

    while read entry ; do

       set -- ${entry}

       if [ "$8" != "$queueName" ] ; then
          continue
       else
          localjobid=$1
          localusername=$4
          status=$5
          OutputJobEntry
       fi

    done < "${tmp_file}"

done

rm ${tmp_file}
