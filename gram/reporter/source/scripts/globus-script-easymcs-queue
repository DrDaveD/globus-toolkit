#! /bin/sh -f
###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to 
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#      
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
#
# SPQ:
# string  stands for                            Globus context meaning
# --------------------------------------------------------------------
# R       Running                               ACTIVE
# C       Clearing                              DONE
# W       Waiting                               PENDING
# S       Job has been Held by the system       PENDING
# U       Job has been Held by the user         PENDING
# ST      Starting                              PENDING
# H       Hog (Job held, too many requests)     PENDING
#
# LLQ:
# string  stands for                            Globus context meaning
# --------------------------------------------------------------------
# C       Completed                     DONE
# D       Deferred                      PENDING
# H       User Hold                     PENDING
# I       Idle                          PENDING
# NR      Not Run                       FAILED
# NQ      Not Queued                    PENDING
# P       Pending                       PENDING
# R       Running                       ACTIVE
# RM      Removed                       FAILED?  (program was cancelled)
# RP      Remove Pending                FAILED?  (program was cancelled)
# S       System Hold                   PENDING
# SH      User Hold and System Hold     PENDING
# ST      Starting                      PENDING
# V       Vacated                       PENDING? (started but did not complete)
# XP      Reject Pending                FAILED
#
########

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-gram-protocol-constants.sh
globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh

# programs used in this script located by autoconf:
llstatus=${GLOBUS_SH_LLSTATUS-llstatus}
spfree=${GLOBUS_SH_SPFREE-spfree}
llq=${GLOBUS_SH_LLQ-llq}
awk=${GLOBUS_SH_AWK-awk}
grep=${GLOBUS_SH_GREP-grep}


############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#

GetNodeCount() {
  if [ -x "${spfree}" ]; then
      usednodes=`${spfree} -i`
      downnodes=`${spfree} -d`

      FREENODES=`${spfree} -f`
      TOTALNODES=`expr $FREENODES + $usednodes + $downnodes`
  else
      FREENODES=0
      TOTALNODES=0
  fi
} #########################


############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue 
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <scheduler value>
#

OutputQueueEntry() {

  # if all required fields have values then output the information
  if [ -n "${clusterid}" ] &&
     [ -n "${owner}" ] &&
     [ -n "${count}" ] &&
     [ -n "${jobstatus}" ] ; then
     echo "GRAM_SCRIPT_QE:startqueueentry"
     echo "GRAM_SCRIPT_QE:localjobid ${clusterid}"
     echo "GRAM_SCRIPT_QE:localusername ${owner}"
     echo "GRAM_SCRIPT_QE:count ${count}"
     echo "GRAM_SCRIPT_QE:status ${jobstatus}"
     echo "GRAM_SCRIPT_QE:endqueueentry"
  fi
  # reset info
  clusterid=""
  owner=""
  jobstatus=""
  count=""
} #########################

################## main section #######################
# Ouput queue values where possible

echo "GRAM_SCRIPT_Q:StartQueue"
GetNodeCount
echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
echo "GRAM_SCRIPT_Q:maxtime 0"
echo "GRAM_SCRIPT_Q:maxCPUtime 0"
echo "GRAM_SCRIPT_Q:maxCount 0"
echo "GRAM_SCRIPT_Q:maxRunningJobs 0"
echo "GRAM_SCRIPT_Q:maxJobsInQueue 0"
echo "GRAM_SCRIPT_Q:maxTotalMemory 0"
echo "GRAM_SCRIPT_Q:maxSingleMemory 0"
echo "GRAM_SCRIPT_Q:whenActive 0"
echo "GRAM_SCRIPT_Q:status 0"
echo "GRAM_SCRIPT_Q:dispatchType batch"
#echo "GRAM_SCRIPT_Q:priority 0"
#echo "GRAM_SCRIPT_Q:allowedUser user1"
#echo "GRAM_SCRIPT_Q:allowedUser user2"
#echo "GRAM_SCRIPT_Q:jobWait 0"
#echo "GRAM_SCRIPT_Q:schedulerSpecific"
echo "GRAM_SCRIPT_Q:notlistingjobentries"
echo "GRAM_SCRIPT_Q:EndQueue"

# loop through all queue entries.  For each entry grab values and call
# function OutputQueueEntry
#
#${llq} or ${spq} | while read entry ; do
#   
#  write code to parse queue entries.  For each call OutputQueueEntry
#  Note: in OutputQueueEntry there is a minimum set of required fields
#
#done
