#! /bin/sh -f

###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to 
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#      
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
#
# string        stands for                      Globus context meaning
# --------------------------------------------------------------------
#  A            ARRIVING        PENDING
#  C            CHECKPOINTED    FAILED  ?
#  D            DEPARTING       PENDING ? (should be suspended if we had that)
#  E            EXITING         DONE
#  H            HELD            PENDING ? (should be suspended if we had that)
#  Q            QUEUED          PENDING
#  P            PREEMPTED       PENDING ? (should be suspended if we had that)
#  R            ROUTING         PENDING ? (should be suspended if we had that)
#  R??          RUNNING         ACTIVE
#  S            SUSPENDED       PENDING ? (should be suspended if we had that)
#  U            UNKNOWN         ????? PENDING
#  W            WAITING         PENDING

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh


# programs used in this script located by autoconf:
qstat=${GLOBUS_GRAM_JOB_MANAGER_QSTAT-qstat}
grmview=${GLOBUS_GRAM_JOB_MANAGER_GRMVIEW-grmview}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
########


############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#
#

GetNodeCount() {

    eval `${grmview} -tlm | ${awk} 'BEGIN {
                avail = 0
                total = 0
        }
        {
                if ( $1 != "+" )
                        next
                if ( $4 <= 1 )
                        next
                total = total + 1
                if ( $6 < $7 )
                        avail = avail + 1
        }
        END {
                print "TOTALNODES=" total
                print "FREENODES=" avail
        }'`

} #########################


############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue 
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <scheduler value>
#

OutputQueueEntry() {

  # if all required fields have values then output the information
  if [ -n "${clusterid}" ] &&
     [ -n "${owner}" ] &&
     [ -n "${count}" ] &&
     [ -n "${jobstatus}" ] ; then
     echo "GRAM_SCRIPT_QE:startqueueentry"
     echo "GRAM_SCRIPT_QE:localjobid ${clusterid}"
     echo "GRAM_SCRIPT_QE:localusername ${owner}"
     echo "GRAM_SCRIPT_QE:count ${count}"
     echo "GRAM_SCRIPT_QE:status ${jobstatus}"
     echo "GRAM_SCRIPT_QE:endqueueentry"
  fi
  # reset info
  clusterid=""
  owner=""
  jobstatus=""
  count=""

} #########################


################## main section #######################
# Ouput queue values where possible

echo "GRAM_SCRIPT_Q:StartQueue"
GetNodeCount
echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
echo "GRAM_SCRIPT_Q:maxtime 0"
echo "GRAM_SCRIPT_Q:maxCPUtime 0"
echo "GRAM_SCRIPT_Q:maxCount 0"
echo "GRAM_SCRIPT_Q:maxRunningJobs 0"
echo "GRAM_SCRIPT_Q:maxJobsInQueue 0"
echo "GRAM_SCRIPT_Q:maxTotalMemory 0"
echo "GRAM_SCRIPT_Q:maxSingleMemory 0"
echo "GRAM_SCRIPT_Q:whenActive 0"
echo "GRAM_SCRIPT_Q:status 0"
echo "GRAM_SCRIPT_Q:dispatchType batch"
#echo "GRAM_SCRIPT_Q:priority 0"
#echo "GRAM_SCRIPT_Q:allowedUser user1"
#echo "GRAM_SCRIPT_Q:allowedUser user2"
#echo "GRAM_SCRIPT_Q:jobWait 0"
#echo "GRAM_SCRIPT_Q:schedulerSpecific"
echo "GRAM_SCRIPT_Q:notlistingjobentries"
echo "GRAM_SCRIPT_Q:EndQueue"

# loop through all queue entries.  For each entry grab values and call
# function OutputQueueEntry
#
#${qstat} | while read entry ; do
#   
#  write code to parse queue entries.  For each call OutputQueueEntry
#  Note: in OutputQueueEntry there is a minimum set of required fields
#
#done
