#! /bin/sh -f
###################################################################
# globus-script-<scheduler>-queue script
# --------------------------------------
#
# The purpose of this script is to communicate the queue values and
# current queue entries (jobs) to the globus-gram-scheduler function.
# This function will then compile the information into C structures to 
# present a uniform interface to more easily facilitate multi queue
# analysis.
#
# queue information is output in the form:
#     GRAM_SCRIPT_Q:<gram queue parameter> <local scheduler value>
#
# queue entry information (i.e. jobs) are output in the form:
#     GRAM_SCRIPT_QE:<gram queue entry parameter> <local scheduler job value>
#      
#
###################################################################
# Below is a conversion chart for this scheduler queue's job status
# value to Globus job status value.
#
# The Status field can contain one of the following strings:
#
# string        stands for                      Globus context meaning
# --------------------------------------------------------------------
# RUN           Running                         ACTIVE
# PEND          Wating to be scheduled          PENDING
# USUSP         Suspended while running         SUSPENDED
# PSUSP         Suspended while pending         SUSPENDED
# SSUSP         Suspended by system             SUSPENDED
# DONE          Completed sucessfully           DONE
# EXIT          Completed unsuccessfully        FAILED
# UNKWN         Unknown state                   FAILED
# ZOMBI         Unknown state                   FAILED

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

globus_source ${libexecdir}/globus-sh-tools.sh
globus_source ${libexecdir}/globus-gram-job-manager-tools.sh


# programs used in this script located by autoconf:
lsload=${GLOBUS_GRAM_JOB_MANAGER_LSLOAD-lsload}
lshosts=${GLOBUS_GRAM_JOB_MANAGER_LSHOSTS-lshosts}
bjobs=${GLOBUS_GRAM_JOB_MANAGER_BJOBS-bjobs}
bqueues=${GLOBUS_GRAM_JOB_MANAGER_BQUEUES-bqueues}
grep=${GLOBUS_SH_GREP-grep}
awk=${GLOBUS_SH_AWK-awk}
tmp_file="${local_tmpdir}/globus_tmp_file.$$"

########


############################################################
#
# GetNodeCount
#
#
# Get free and total nodes from the system
#
# Some comments about how TOTALNODES and FREENODES is obtained:
#
#
# TOTALNODES:
# The lshosts command is used to obtain information about all
# the hosts known to LSF. The header line is removed and the remaining
# output is checked for the whether or not the hosts is a server.
# If so, information about the number of cpus is gathered.
#
# FREENODES:
# The lsload command is used to obtain information about the load
# on LSF configured host. The header line is removed and the remaining
# output is filtered by the status field. If the field value is "ok"
# then the r1m field is used to represent the load.
#

GetNodeCount() {


if (test ! -x "$lsload") || (test ! -x "$lshosts") ; then
    echo "cannot find one of the LSF needed commands" \
                "to determine load/node information!"
    echo "setting free nodes to zero."
    FREENODES=0
else
    TOTALNODES=`$lshosts | ${grep} -v HOST_NAME | ${grep} Yes \
                 | ${awk} ' {sum += $5} END {print sum}' `

    LOAD=`${lsload} | ${grep} -v HOST_NAME \
             | ${awk} ' /ok/ {sum += $4} END {print int(sum+.05)}'`
    FREENODES=`expr $TOTALNODES - $LOAD`
fi

} #########################


############################################################
#
# OutputJobEntry
#
#
# convert scheduler specific information to the standard GRAM queue
# entry parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <Job Entry Value>
#

OutputJobEntry() {

	echo "GRAM_SCRIPT_QE:startqueueentry"
	echo "GRAM_SCRIPT_QE:localjobid ${localjobid}"
	echo "GRAM_SCRIPT_QE:localusername ${localusername}"
#	echo "GRAM_SCRIPT_QE:count ${count}"
	echo "GRAM_SCRIPT_QE:status ${status}"
	echo "GRAM_SCRIPT_QE:queueName ${queueName}"
	echo "GRAM_SCRIPT_QE:endqueueentry"

}

############################################################
#
# OutputQueueEntry
#
#
# convert scheduler specific information to the standard GRAM queue
# parameters.
#
# format GRAM_SCRIPT_QE:<GRAM parameter> <Queue Value>

OutputQueueEntry() {

echo "GRAM_SCRIPT_Q:StartQueue"
echo "GRAM_SCRIPT_Q:totalNodes ${TOTALNODES}"
echo "GRAM_SCRIPT_Q:freeNodes ${FREENODES}"
echo "GRAM_SCRIPT_Q:queueName ${queueName}"
echo "GRAM_SCRIPT_Q:maxtime 0"
echo "GRAM_SCRIPT_Q:maxCPUtime 0"
echo "GRAM_SCRIPT_Q:maxCount 0"
echo "GRAM_SCRIPT_Q:maxRunningJobs ${maxRunningJobs}"
echo "GRAM_SCRIPT_Q:maxJobsInQueue ${maxJobsInQueue}"
echo "GRAM_SCRIPT_Q:maxTotalMemory 0"
echo "GRAM_SCRIPT_Q:maxSingleMemory 0"
echo "GRAM_SCRIPT_Q:whenActive 0"
echo "GRAM_SCRIPT_Q:status ${status}"
echo "GRAM_SCRIPT_Q:dispatchType batch"
echo "GRAM_SCRIPT_Q:priority ${priority}"
#echo "GRAM_SCRIPT_Q:jobWait 0"
#echo "GRAM_SCRIPT_Q:schedulerSpecific"
echo "GRAM_SCRIPT_Q:notlistingjobentries"
echo "GRAM_SCRIPT_Q:EndQueue"

}

################## main section #######################

# Output Node information

# Ouput queue values where possible

GetNodeCount

#
# Obtain and ouput queue and job information
# loop through all queues and report queue information and information
# about each job in that queue. 
#
# Must use shift since accessible number of positional parameters is limited
# to less than 9.

# Collect job information into file for later processing

${bjobs} -u all  | grep -v "JOBID" > "${tmp_file}"

# Collect queue information 

${bqueues} | while read entry ; do

	if [ $? != 0 ] ; then
		break
		fi

	set -- ${entry}

	if [ "$1" = "QUEUE_NAME" ] ; then
	   continue
	   fi

	queueName=$1
	shift

	priority=$1
	shift

	status=$1
	shift

	if [ "$1" = "-" ] ; then
		maxJobsInQueue="unlimited"
	else
		maxJobsInQueue=$1
	fi

	shift 6
	maxRunningJobs=$1

	OutputQueueEntry

# obtain  information about jobs in this queue 

	while read entry ; do

   		set -- ${entry}

		if [ "$4" != "$queueName" ] ; then
			continue
		else
			localjobid=$1
			localusername=$2
			status=$3
			OutputJobEntry
		fi

	done < "${tmp_file}"

done

rm ${tmp_file}

################################################
#
# The purpose of this function is to parse the long listing of queue
# information to extract additional queue attributes like cpu and
# memory limits.
#
# This function is not yet implemented.
#
# Ouput queue information
# loop through all queue entries.  For each entry grab values and call
# function OutputQueueEntry
#
#
#"${bqueues}" | grep -v QUEUE_NAME  | cut -d" " -f1 > "${tmp_file}"
#
#exec < "${tmp_file}"
#
#count=0
#while [ 1 ] ; do
#read entry
#
#if [ $? != 0 ] ; then
#   break
#   fi
#
#echo New queue name = $entry...
#count=`expr $count + 1`
#echo $count
#${bqueues} -l $entry | while read line ; do
#
#if [ $? != 0 ] ; then
#   break
#   fi
#
#set -- ${line}
#
##echo Line is $line
#
#case "$1" in
#
#   QUEUE: )
#       queueName=$2
#       read line
#       set -- ${line}
#       echo $line
#        ;;
#
#   USERS: )
#       echo Key=USERS
#       echo Line is $line
#       ;;
#
#   DISPATCH_WINDOW: )
#       echo Key=DISPATH_WINDOW
#       echo Line is $line
#       ;;
#   * )
#       echo "Line not of interest"
#       continue
#       ;;
#esac
#
#OutputQueueEntry
#
#done
#
#done
#
#rm "${tmp_file}"

