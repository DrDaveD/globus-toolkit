Stateful eventd:
loop
    if (check for log msg)
        if subscribed-to:
            propogate to RIPS2
        else
            enqueue in soft-state expiry queue for N mins
    sleep?

at restart:
    do poll loop as before from last log msg update sent for, storing
        all soft state events if younger than N mins

check for log msg:
    if (inode != old inode || size != old size):
        read rest of msgs in file

data we keep in core:
    soft state queue of events with no subscription
data we keep persistent:
    list of subscribed to job ids
    last log file stat data (inode, file size)

RIPS2 starts eventd 
 - communication:
     - stdin is a socket to receive control msgs on (pipes?)
       stdout is a socket to send events on
     OR
     - pass port # to RIPS2 listener socket to send notifications to
     
 - asks for state on specific job ids on stdin, which results in subscription,
   sending of any not-timed out events in the queue.
 - sends subscribe/unsubscribe on stdin
 - responds with events on stdout (format?)

Semi-stateful eventd (soft state in RIPS2):
 - acts as above, but
   - pushes *all* events to RIPS2
   - doesn't keep track of subscriptions [ no subscribe protocol ]
   - keeps last log file stat data in persistent storage
   - stores persistently last log file status of last log msg handled. (inode,
     offset)

 RIPS2 stores
 - job ID, state changes w/timestamps and soft state information
 - when restarted, RIPS2 expires any soft state information it had which
   is too old then starts eventd to parse new events.

Stateless eventd
 - RIPS2 starts eventd with timestamp of last event it processed. Eventd
   starts cranking out events for everything which happened since then.
-----------------------------------------------------------------------------

/**
 * Interface implemented by the Managed Job Service to receive scheduler-
 * initiated state change events.
 */
interface JobMonitorListener {
    /*
     * Sets the current resource context state to contain the resource key
     * of the resource associated with the local job identifier.
     */
    void deliverJobMonitorEvent(java.util.Date timestamp, int state,
            int exitCode[]);
};

class JobMonitor {
    void initialize(ManagedJobFactory mjf, JobMonitorListener listener);

    void registerJobMapping(String localId, Object resourceKey)
            throws AlreadyRegisteredException;

    void unregisterJobMapping(String localId, Object resourceKey)
            throws NotRegisteredException;
};

-----------------------------------------------------------------------------
Eventd API:
Schedulers will send eventd messages using this API.

/**
 * Format and send an arbitrary event message to the SchedulerMonitor
 * implementation. This is used to implement the rest of the event signalling
 * API.
 *
 * @param format
 *     Format string using the same format as described in the printf
 *     manual page.
 * @param ...
 *     Varargs values used for type conversions in the format string.
 * @retval 0
 *    Message sent.
 */
int
globus_scheduler_event(
    const char * format,
    ...);

/**
 * Send a job pending event to the SchedulerMonitor implementation.
 *
 * @param timestamp
 *        Timestamp to use for the event. If set to 0, the time which
 *        this function was called is used.
 * @param username
 *        String naming the local user who owns the job.
 * @param jobid
 *        String indicating the scheduler-specific name of the job.
 * @retval 0
 *    Message sent.
 */
int
globus_scheduler_event_pending(
    time_t                              timestamp,
    const char *                        username,
    const char *                        jobid);

int
globus_scheduler_event_active(
    time_t                              timestamp,
    const char *                        userid,
    const char *                        jobid);

int
globus_scheduler_event_failed(
    time_t                              timestamp,
    const char *                        userid,
    const char *                        jobid,
    int                                 num_failure_codes,
    int *                               failure_code);

int
globus_scheduler_event_done(
    time_t                              timestamp,
    const char *                        userid,
    const char *                        jobid,
    int                                 num_exit_codes,
    int *                               exit_codes);

Eventd message format:
- MESSAGE_TYPE;<message type specific info>

MESSAGE TYPE 001:
001;TIMESTAMP;JOBID;STATE;EXIT_CODE
MESSAGE TYPE should be 001 for job state changes
TIMESTAMP format is text representation of unix seconds since the epoch
JOBID is scheduler-specific job identifier string 
STATE is integer job state
EXIT_CODE is integer job exit or failure code (if aborted). May contain
 (empty when job state is not done or failed)

Example:
001;1082667232;1234.0;1;
    (Job 1234.0 became PENDING at Thu Apr 22 16:53:52 2004)
001;1082667252;1234.0;2;
    (Job 1234.0 became ACTIVE at Thu Apr 22 16:54:12 2004)
001;1082667290;bester;1234.0;8;0
    (Job 1234.0 became DONE with exit code '0' at Thu Apr 22 16:54:50 2004)
