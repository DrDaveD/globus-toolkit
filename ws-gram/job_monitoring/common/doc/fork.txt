- Fork
  - polling in script (current)
    - kill -0 <list of pids> to find out what's finished
      Unable to get exit code from this method (only parent process can get
      that via wait()) (could also be implemented in c code via kill(2) if
      c code has same uid as process)
  - polling in script via ps (hbm tried this)
    - various output formats for ps (not entirely portable).
    - slow, high overhead
  - polling in parent process (C code)
    - waitpid(-pgid, &status, WNOHANG); (poll for children processes which
      have completed, getting exit status code) --- if we are restarted, we
      can't wait on child pid. If we die after waitpid but before recording
      the resulting status, it is lost (need to have same uid as job processes)
  - blocking parent process until children complete
    - waitpid(-1, &status, 0); (block thread until any child exits) -- if we
      are restarted, we can't do this anymore (need to have same uid as job
      processes)
  - signal handling in parent process (C code)
    - catching SIGCHLD in parent process to get signalled when the children
      are completed, then doing waitpid to reap the process information. [BEST?]
    - (Do signal handlers exist in Java)
  - using ptrace to attach to existing processes (C code)
    - (plus) can do this when not parent and can get exit code (with similar
      caveats to above)
    - (minus) jobs can't be attached to by a debugger
    - (minus) monitor must propagate signals to the processes whenever they
      would receive a signal
    - (minus) may not be easily portable
    - must have same uid as child
  - Process polling in Java
    - int Process.exitValue() can return process exit code for child process
      created by Runtime.exec() (no support for non-child processes). If
      job is not finished, then exception is raised (potentially more polling
      overhead). No support for wildcard process ids or process groups.
    - int Process.waitFor() can return process exit code for child process
      created by Runtime.exec() (no support for non-child processes). if
      job is not finished, current thread will block). No support for wildcard
      process ids or process groups.
-------------
Potential Design (c language job starter/eventd):
- 1 process per user (for stability---or 1 per host for scalability and use
  sudo to begin the jobs)
  Purpose: create and monitor fork jobs
  - create by direct fork()ing
    - log pid(s) in job file
  - monitor in two ways
    - signal-driven monitoring of jobs
    - pid file checks for reliability after restart
Pseudocode (assuming hold + commit for job startup, signal delivery for
            termination detection)
- main
  scan pid dir (to load pids of jobs which were started by previous
    incarnation of the monitor)
  install sigchild handler
  while ()
  {
      if (something available on stdin)
      {
          read stdin;
      }

      if (new job cmd from stdin)
      {
          fork()
          if (child)
          {
              establish signal handler for hold release (USR1)
              set alarm for hold timeout

              pause() /* wait for hold release or alarm signal */

              if (hold released)
              {
                  clear alarm
                  print execing msg to stdout
                  exec()
                  if (exec failed)
                      exit with some failure code)
              }
              else if (alarm)
              {
                  exit with some failure code
              }
          }
          if (parent)
          {
              write job pids or pgid to file in pending dir
              write job pids or pgid to stdout
          }
      }
      if (release hold on pgid on stdin)
      {
          signal USR1 to child
          move job pid to active dir if signal successful.
      }
      if (sigchild delivered since we last checked)
      {
          pid = wait3(&status, WNOHANG, &rusage);
          add pid to finished list
      }
      if (recovery pids list is not empty)
      {
          foreach (pgid)
          kill(-pgid, 0); /* determine if pg still alive */

          if (something finished)
          {
              add pids to finished list
          }
      }
      if (finished list not empty)
      {
          signal finishedness to rips2 thing (how?)
          when acked, remove job file
      }
  }

TODO:
Relate this implementation design to the eventd and JobMonitor description.
Figure out # of simultaneous users we can support with this design.
