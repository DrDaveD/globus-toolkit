#!/usr/bin/perl -w

use strict;

use Getopt::Long;

my $opt_debug_pgms = 0;

my @packages;
my %pgm_flavors;
my %pgm_static_flavors;

my $package;

my $name;
my $flavor;
my $type;


GetOptions(
    "prefer-debug-pgms"   => \$opt_debug_pgms
);


sub pick_best_flavor
{
    my $flavor1 = shift;
    my $flavor2 = shift;

    # empty flavors always loose
    if (!defined($flavor1) or $flavor1 eq "") { return $flavor2; }
    if (!defined($flavor2) or $flavor2 eq "") { return $flavor1; }

    if ($opt_debug_pgms)
    {
        # dbg wins over non-dbg
        if ( $flavor1 =~ m/dbg/ and !($flavor2 =~ m/dbg/) ) { return $flavor1; }
        if ( $flavor2 =~ m/dbg/ and !($flavor1 =~ m/dbg/) ) { return $flavor2; }
    }
    else
    {
        # non-dbg wins over dbg
        if ( !($flavor1 =~ m/dbg/) and $flavor2 =~ m/dbg/) { return $flavor1; }
        if ( !($flavor2 =~ m/dbg/) and $flavor1 =~ m/dbg/) { return $flavor2; }
    }

    # 64 bit wins over 32 bit
    if ($flavor1 =~ m/64/ and $flavor2 =~ m/32/) { return $flavor1; }
    if ($flavor2 =~ m/64/ and $flavor1 =~ m/32/) { return $flavor2; }

    # non-pthr wins over pthr
    if ( !($flavor1 =~ m/pthr/) and $flavor2 =~ m/pthr/ ) { return $flavor1; }
    if ( !($flavor2 =~ m/ptrh/) and $flavor1 =~ m/pthr/ ) { return $flavor2; }

    # vendorcc wins over gcc
    if ($flavor1 =~ m/vendorcc/ and $flavor2 =~ m/gcc/) { return $flavor1; }
    if ($flavor2 =~ m/vendorcc/ and $flavor1 =~ m/gcc/) { return $flavor2; }

    # at this point it does not matter which flavor we choose
    return $flavor1;
}


sub add_package
{
    my $name   = shift;
    my $flavor = shift;
    my $type   = shift;

    push(@packages, "            <Package PackageFlavor=\"$flavor\"" .
                    " PackageName=\"$name\" PackageType=\"$type\" />");
}


open(QUERY, "gpt-query |");
while (<QUERY>)
{
    m/^\s+(\S+)-(\S+)-(\S+)\s/;

    if ($1)
    {
        $name   = $1;
        $flavor = $2;
        $type   = $3;

        # pgms are the only ones which can conflict
        # store the best flavor choice in the pgm flavor list
        # the idea is to keep only the best flavor of each package
        if ($name eq "globus_core")
        {
            # should we always skip these packages?
        }
        elsif ($type eq "pgm")
        {
            $pgm_flavors{$name} = pick_best_flavor($flavor, 
                                                   $pgm_flavors{$name});
        }
        elsif ($type eq "pgm_static")
        {
            $pgm_static_flavors{$name} = pick_best_flavor($flavor, 
                                             $pgm_static_flavors{$name});
        }
        else
        {
            add_package($name, $flavor, $type);
        }
    }
}
close(QUERY);

foreach $name (sort keys %pgm_flavors)
{
     add_package($name, $pgm_flavors{$name}, "pgm");
}

foreach $name (sort keys %pgm_static_flavors)
{
     add_package($name, $pgm_static_flavors{$name}, "pgm_static");
}

print <<EOT
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE GPTBundleData SYSTEM "gpt_bundle.dtd">
<GPTBundleData Name="notnamed" >
    <BundleInfo >
        <Description >EMPTY</Description>
        <PackagingTool ToolName="GPT" ToolVersion="3.2" />
        <ContactInfo ContactEmail="EMPTY" ContactName="EMPTY" />
        <BundleDocs BundleDocsDesc="EMPTY" BundleDocsURL="EMPTY" />
    </BundleInfo>
    <BundleReleaseInfo >
        <BundleStability Release="EMPTY" />
        <BundleVersion Age="EMPTY" Major="EMPTY" Minor="EMPTY" />
        <VersionLabel >nmi-7.0</VersionLabel>
        <TypeOfBundle ContentsType="gpt" />
    </BundleReleaseInfo>
    <PackageList >
        <IncludedPackages >
EOT
;

foreach $package (@packages)
{
    print "$package\n";
}

print <<EOT
        </IncludedPackages>
        <ExcludedPackages >
        </ExcludedPackages>
        <PackageFlags >
        </PackageFlags>
    </PackageList>
</GPTBundleData>
EOT
;

exit 0;

