#!//usr/bin/perl -W
use strict;

#
# Do a perl check for version >= 5.005.  See 'gpt-translate-interpreter' should you
# need to alter the invocation path to a valid perl interpreter in the GPT front-end
# programs.
#

if ( ! ( defined eval "require 5.005" ) )
{
    die "GPT requires at least Perl version 5.005";
}

# Initialise filenames and check they're there

sub pod2usage {
  my $ex = shift;
  print "gpt_convert_xml <pkg_data_file>\n";
  exit $ex;
}

my $fname = $ARGV[0];

unless(-f $fname) 
{
  print STDERR "FILE: \'$fname\' not found\n";
  pod2usage;
  exit 0;
}

my $t = 1;

##############################################################################
#                   S U P P O R T   R O U T I N E S
##############################################################################

##############################################################################
# Print out 'n ok' or 'n not ok' as expected by test harness.
# First arg is test number (n).  If only one following arg, it is interpreted
# as true/false value.  If two args, equality = true.
#

sub ok {
  my($n, $x, $y) = @_;
  die "Sequence error got $n expected $t" if($n != $t);
  $x = 0 if(@_ > 2  and  $x ne $y);
  print(($x ? '' : 'not '), 'ok ', $t++, "\n");
}





my $DOWARN = 1;
BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } };
my $gpath = $ENV{GPT_LOCATION};

if (!defined($gpath))
{
  $gpath = $ENV{GLOBUS_LOCATION};
}

if (!defined($gpath))
{
  die "GPT_LOCATION or GLOBUS_LOCATION needs to be set before running this script"
}

@INC = (@INC, "$gpath/lib/perl");

require Grid::GPT::XML;
require Grid::GPT::V1::Package;
require Grid::GPT::Definitions;

my $xml = new Grid::GPT::XML;
my $doSetup = 0;

## Default values
my $gptName = 'DFAULT';
my $gptFVer = 'DFAULT';
my $gptDesc = 'DFAULT';
my $gptStab = 'DFAULT';
my $gptComp = 'DFAULT';
my $gptWflv = 'DFAULT';
my $gptSys  = 'DFAULT';
my $gptMaj  = '0';
my $gptMin  = '0';
my $gptAge  = '0';

my $info_filename = $fname;
my $path = '';
my $basename = '';

if ($info_filename =~ /\//) 
{
  ($path, $basename) 
       = ( $info_filename =~ /^(.*)\/(.*)$/ );
} 
else 
{
  $basename = $info_filename;
  $path = "";
}


my $cnvdFile = 'CONV_' . $basename;
my $setFile = 'CONV_SETUP_' . $basename;

print "Convert file: $fname\n";
 
open (OUTFILE, , ">$cnvdFile") or die "ERROR: cannot open $cnvdFile\n";

$xml->read($fname);

my $root = $xml->{'roottag'};

print OUTFILE "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

$gptSys = $xml->{'system'}
    if( defined $xml->{'system'} );

print OUTFILE "<!DOCTYPE GPTPackageMetadata SYSTEM \"$gptSys\">\n";

$gptName = $root->{'attributes'}->{'Name'}
    if( defined $root->{'attributes'}->{'Name'} );
$gptFVer = $root->{'attributes'}->{'Format_Version'}
    if( defined $root->{'attributes'}->{'Format_Version'} );

print OUTFILE "<GPTPackageMetadata Name=\"$gptName\" FormatVersion=\"$gptFVer\">\n";

print OUTFILE "## Place for FeatureSetIdentity\n";


  for my $c (@{$root->{'contents'}}) 
  {
    next if ref($c) ne 'HASH';

    if( $c->{'name'} eq 'Description' )
    {
      print OUTFILE "<PackageInfo>\n";
      $gptDesc = $c->{'contents'}->[0]
          if( defined $c->{'contents'}->[0] );
      print OUTFILE "<Description>$gptDesc</Description>\n";
      print OUTFILE "## Place for ContactInfo\n";
      print OUTFILE "## Place for PackageDocs\n";
      print OUTFILE "</PackageInfo>\n";
    }

    if( $c->{'name'} eq 'Aging_Version' )
    {
      $gptMaj = $c->{'attributes'}->{'Major'}
          if( defined $c->{'attributes'}->{'Major'} ); 
      $gptMin = $c->{'attributes'}->{'Minor'}
          if( defined $c->{'attributes'}->{'Minor'} ); 
      $gptAge = $c->{'attributes'}->{'Age'}
          if( defined $c->{'attributes'}->{'Age'} ); 
    }

    if( $c->{'name'} eq 'Version_Stability' )
    {
      print OUTFILE "<PackageReleaseInfo>\n";
      $gptStab = $c->{'attributes'}->{'Release'}
          if( defined $c->{'attributes'}->{'Release'} );

      print OUTFILE "<PackageStability Release=\"$gptStab\"/>\n";
      print OUTFILE "<CompatibilityIdentifier Major=\"$gptMaj\" Minor=\"$gptMin\" Age=\"$gptAge\"/>\n";
      print OUTFILE "</PackageReleaseInfo>\n";
    }

    if ($c->{'name'} =~ m!(.+)_pkg$!)
    {
      my $Package_Type = $1;
      my $endtag = '';

      if( $Package_Type eq 'data' )
      {
        print OUTFILE "<DataPackage>\n";
        $endtag = '</DataPackage>';
      }
      elsif( $Package_Type eq 'dev' )
      {
        print OUTFILE "<DevelopmentPackage>\n";
        $endtag = '</DevelopmentPackage>';
      }
      elsif( $Package_Type eq 'doc' )
      {
        print OUTFILE "<DocPackage>\n";
        $endtag = '</DocPackage>';
      }
      elsif( $Package_Type eq 'hdr' )
      {
        print OUTFILE "<HeaderPackage>\n";
        $endtag = '</HeaderPackage>';
      }
      elsif( $Package_Type eq 'pgm' )
      {
        print OUTFILE "<PGMPackage>\n";
        $endtag = '</PGMPackage>';
      }
      elsif( $Package_Type eq 'pgm_static' )
      {
        print OUTFILE "<PGMStaticPackage>\n";
        $endtag = '</PGMStaticPackage>';
      }
      elsif( $Package_Type eq 'rtl' )
      {
        print OUTFILE "<RTLPackage>\n";
        $endtag = '</RTLPackage>';
      }
      elsif( $Package_Type eq 'src' )
      {
        print OUTFILE "<SourcePackage>\n";
        $endtag = '</SourcePackage>';
      }
      elsif( $Package_Type eq 'virtual' )
      {
        print OUTFILE "Don't know what to do with this\n";
        exit;
      }

      foreach my $sc (@{$c->{'contents'}})
      {
        next if ref($sc) ne 'HASH';

        if( $sc->{'name'} eq 'With_Flavors' )
        {
          my $wFlav = 'No';

          $wFlav = $sc->{'attributes'}->{'build'}
              if( defined $sc->{'attributes'}->{'build'} );

          print OUTFILE "<WithFlavors Build=\"$wFlav\"/>\n";
        }

        if( $sc->{'name'} eq 'Source_Dependencies' )
        {
          convertSrc( $sc );
        }

        if( $sc->{'name'} eq 'Binary_Dependencies' )
        {
          convertBin( $sc );
        }

        if( $sc->{'name'} eq 'Flavor' )
        {
          my $flav = '';

          $flav = $sc->{'contents'}->[0]
              if( defined $sc->{'contents'}->[0] );

          print OUTFILE "<Flavor>$flav</Flavor>\n";
        }

        if ($sc->{'name'} eq 'Post_Install_Message') 
        {
          if( $Package_Type ne 'pgm' and $Package_Type ne 'pgm_static' )
          {
            next;
          }
          my $pstMsg = '';

          $pstMsg = $sc->{'contents'}->[0]
              if( defined $sc->{'contents'}->[0] );
          print OUTFILE "<PostInstallMessage>$pstMsg</PostInstallMessage>\n";
          next;
        }

        if ($sc->{'name'} eq 'Post_Install_Program') 
        {
          if( $Package_Type ne 'pgm' and $Package_Type ne 'pgm_static' )
          {
            next;
          }
          my $pstPgm = '';

          $pstPgm = $sc->{'contents'}->[0]
              if( defined $sc->{'contents'}->[0] );
          print OUTFILE "<PostInstallProgram>$pstPgm</PostInstallProgram>\n";
          next;
        }

        if ($sc->{'name'} eq 'Setup') 
        {
##print "Setup: $sc->{'attributes'}->{'Name'}\n";

          for my $setc (@{$sc->{'contents'}}) 
          {
            next if ref($setc) ne 'HASH';

            if ($setc->{'name'} eq 'Aging_Version') 
            {
##print Dumper $setc;
              last;
            }
          }
        }

        if ($sc->{'name'} eq 'Build_Environment') 
        {
          my $tmps;

          print OUTFILE "<BuildEnvironment>\n";

          for my $bc (@{$sc->{'contents'}}) 
          {
            next if ref($bc) ne 'HASH';

            $tmps->{$bc->{'name'}} = $bc->{'contents'}->[0];
            ##print OUTFILE "<$bc->{'name'}>$bc->{'contents'}->[0]</$bc->{'name'}>\n";
          }
          foreach my $i ('cflags','pkg_libs','external_libs','external_includes')
          {
            my $str;
            if( $i eq 'cflags' )
            {
              $str = 'Cflags';
            }
            elsif( $i eq 'pkg_libs' )
            {
              $str = 'PackageLibs';
            }
            elsif( $i eq 'external_libs' )
            {
              $str = 'SystemLibs';
            }
            elsif( $i eq 'external_includes' )
            {
              $str = 'SystemIncludes';
            }
            print OUTFILE "<$str>$tmps->{$i}</$str>\n";
          }

          print OUTFILE "</BuildEnvironment>\n";
          next;
        }

        if ($sc->{'name'} eq 'Build_Instructions') 
        {
          print OUTFILE "<BuildInstructions>\n";

          for my $bc (@{$sc->{'contents'}}) 
          {
            next if ref($bc) ne 'HASH';

            my $name = $bc->{'name'};
            if ($name eq 'Build_Step') 
            {

              my $command = $bc->{'contents'}->[0];
              $command =~ s!\n$!!s;
              my $args = ''; 
              $args = "MacroArgs=\"$bc->{'attributes'}->{'Macro_Args'}\" "
                  if( defined $bc->{'attributes'}->{'Macro_Args'} );
              print OUTFILE "<BuildStep $args Step=\"$command\"/>\n";
              next;
            }
            if ($name eq 'flavors') 
            {
              print OUTFILE "<FlavorChoice>\n";

              foreach my $fc (@{$bc->{'contents'}})
              {
                next if ref($fc) ne 'HASH';

		if( $fc->{'name'} eq 'flavor_choice' )
		{
		  print OUTFILE "<FlavorConfig>\n";

		  foreach my $fo (@{$fc->{'contents'}})
		  {
		    next if ref($fo) ne 'HASH';

                    if( $fo->{'name'} eq 'flavor_label' )
                    {
                      my $lb = '';
                      my $sw = '';

                      $lb = $fo->{'attributes'}->{'label'}
                          if( defined $fo->{'attributes'}->{'label'} );
                      $sw = $fo->{'attributes'}->{'conf'}
                          if( defined $fo->{'attributes'}->{'conf'} );
                      print OUTFILE "<FlavorOption FlavorLabel=\"$lb\" FlavorSwitch=\"$sw\"/>\n";
                    }
                    elsif( $fo->{'name'} eq 'noflavor_label' )
                    {
                      print OUTFILE "<InvalidFlavors FlavorLabel=\"$fo->{'attributes'}->{'label'}\"/>\n"
                          if( defined $fo->{'attributes'}->{'label'} );
                    }
                  }
                  print OUTFILE "</FlavorConfig>\n";
                }
              }
              print OUTFILE "</FlavorChoice>\n";
            }
          }
          print OUTFILE "</BuildInstructions>\n";
          next;
        }

        if( ($sc->{'name'} eq 'Source_Setup_Dependency') or
            ($sc->{'name'} eq 'Setup_Dependency') )
        {
          $doSetup = 1;
        }

        if ($sc->{'name'} eq 'Version_Label') {
            # Version_Label has its value in the content array
            # which has 1 element
          print OUTFILE "$sc->{'contents'}->[0]\n";
          next;
        }
      }
      print OUTFILE "$endtag\n";
    }
  }
print OUTFILE "</GPTPackageMetadata>\n";
close OUTFILE;
open (OUTFILE, , ">$setFile") or die "ERROR: cannot open $setFile\n";

if( $doSetup == 1 )
{
  my $root = $xml->{'roottag'};

  print OUTFILE "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
  print OUTFILE "<!DOCTYPE GPTPackageMetadata SYSTEM \"$gptSys\">\n";
  print OUTFILE "<GPTPackageMetadata Name=\"$gptName\" FormatVersion=\"$gptFVer\">\n";

  print OUTFILE "## Place for FeatureSetIdentity\n";


  for my $c (@{$root->{'contents'}}) 
  {
    next if ref($c) ne 'HASH';

    if( $c->{'name'} eq 'Description' )
    {
      print OUTFILE "<PackageInfo>\n";
      print OUTFILE "<Description>$gptDesc</Description>\n";
      print OUTFILE "## Place for ContactInfo\n";
      print OUTFILE "## Place for PackageDocs\n";
      print OUTFILE "</PackageInfo>\n";
    }

    if( $c->{'name'} eq 'Version_Stability' )
    {
      print OUTFILE "<PackageReleaseInfo>\n";
      print OUTFILE "<PackageStability Release=\"$gptStab\"/>\n";
      print OUTFILE "<CompatibilityIdentifier Major=\"$gptMaj\" Minor=\"$gptMin\" Age=\"$gptAge\"/>\n";
      print OUTFILE "</PackageReleaseInfo>\n";
    }

    if ($c->{'name'} =~ m!(.+)_pkg$!)
    {
      my $endtag = '';

      print OUTFILE "<SetupPackage>\n";
      $endtag = '</SetupPackage>';

      foreach my $sc (@{$c->{'contents'}})
      {
        next if ref($sc) ne 'HASH';

        if ($sc->{'name'} eq 'Post_Install_Message') 
        {
          my $pm = '';

          $pm = $sc->{'contents'}->[0]
              if( defined $sc->{'contents'}->[0] );
          print OUTFILE "<PostInstallMessage>$pm</PostInstallMessage>\n";
          next;
        }

        if ($sc->{'name'} eq 'Post_Install_Program') 
        {
          my $pi = '';

          $pi = $sc->{'contents'}->[0]
              if( defined $sc->{'contents'}->[0] );
          print OUTFILE "<PostInstallProgram>$pi</PostInstallProgram>\n";
          next;
        }

        if ($sc->{'name'} eq 'Setup') 
        {
##print "Setup: $sc->{'attributes'}->{'Name'}\n";

          for my $setc (@{$sc->{'contents'}}) 
          {
            next if ref($setc) ne 'HASH';

            if ($setc->{'name'} eq 'Aging_Version') 
            {
##print Dumper $setc;
              last;
            }
          }
        }

        if ($sc->{'name'} eq 'Build_Environment') 
        {
          my $tmps;

          print OUTFILE "<BuildEnvironment>\n";

          for my $bc (@{$sc->{'contents'}}) 
          {
            next if ref($bc) ne 'HASH';

            $tmps->{$bc->{'name'}} = $bc->{'contents'}->[0];
            ##print OUTFILE "<$bc->{'name'}>$bc->{'contents'}->[0]</$bc->{'name'}>\n";
          }
          foreach my $i ('cflags','pkg_libs','external_libs','external_includes')
          {
            my $str;
            if( $i eq 'cflags' )
            {
              $str = 'Cflags';
            }
            elsif( $i eq 'pkg_libs' )
            {
              $str = 'PackageLibs';
            }
            elsif( $i eq 'external_libs' )
            {
              $str = 'SystemLibs';
            }
            elsif( $i eq 'external_includes' )
            {
              $str = 'SystemIncludes';
            }
            print OUTFILE "<$str>$tmps->{$i}</$str>\n";
          }

          print OUTFILE "</BuildEnvironment>\n";
          next;
        }

        if ($sc->{'name'} eq 'Build_Instructions') 
        {
          print OUTFILE "<BuildInstructions>\n";

          for my $bc (@{$sc->{'contents'}}) 
          {
            next if ref($bc) ne 'HASH';

            my $name = $bc->{'name'};
            if ($name eq 'Build_Step') 
            {

              my $command = $bc->{'contents'}->[0];
              $command =~ s!\n$!!s;
              my $args = ''; 
              $args = "MacroArgs=\"$bc->{'attributes'}->{'Macro_Args'}\" "
                  if( defined $bc->{'attributes'}->{'Macro_Args'} );
              print OUTFILE "<BuildStep $args Step=\"$command\"/>\n";
              next;
            }
            if ($name eq 'flavors') 
            {
              print OUTFILE "<FlavorChoice>\n";

              foreach my $fc (@{$bc->{'contents'}})
              {
                next if ref($fc) ne 'HASH';

		if( $fc->{'name'} eq 'flavor_choice' )
		{
		  print OUTFILE "<FlavorConfig>\n";

		  foreach my $fo (@{$fc->{'contents'}})
		  {
		    next if ref($fo) ne 'HASH';

                    if( $fo->{'name'} eq 'flavor_label' )
                    {
                      my $lb = '';
                      my $sw = '';

                      $lb = $fo->{'attributes'}->{'label'}
                          if( defined $fo->{'attributes'}->{'label'} );
                      $sw = $fo->{'attributes'}->{'conf'}
                          if( defined $fo->{'attributes'}->{'conf'} ); 
                      print OUTFILE "<FlavorOption FlavorLabel=\"$lb\" FlavorSwitch=\"$sw\"/>\n";
                    }
                    elsif( $fo->{'name'} eq 'noflavor_label' )
                    {
                      print OUTFILE "<InvalidFlavors FlavorLabel=\"$fo->{'attributes'}->{'label'}\"/>\n"
                          if( defined $fo->{'attributes'}->{'label'} );
                    }
                  }
                  print OUTFILE "</FlavorConfig>\n";
                }
              }
              print OUTFILE "</FlavorChoice>\n";
            }
          }
          print OUTFILE "</BuildInstructions>\n";
          next;
        }

        if( ($sc->{'name'} eq 'Source_Setup_Dependency') )
        {
          convertSrc( $sc );
        }

        if( $sc->{'name'} eq 'Setup_Dependency' )
        {
          convertSetup( $sc );  
        }

      }
      print OUTFILE "$endtag\n";
    }
  }
print OUTFILE "</GPTPackageMetadata>\n";
close OUTFILE;
}

exit;

$xml->write('conv.out');

my $result = ! system("diff -b conv.out $fname");
ok($t, $result);

sub convertSetup
{
  my $args    = shift; 
  my $endtag  = '';
  my $depType = '';

  print OUTFILE "<BinaryDependencies>\n";

  print OUTFILE "<BinaryRuntime Type=\"Setup\">\n";

  print OUTFILE "<Dependency Name=\"$args->{'attributes'}->{'Name'}\" Package=\"pgm\" AllowSubstitution=\"No\">\n";
  for my $pkg (@{$args->{'contents'}}) 
  {
    next if ref($pkg) ne 'HASH';

      foreach my $cmpreq (@{$pkg->{'contents'}})
      {
        next if ref($cmpreq) ne 'HASH';

        if( $cmpreq->{'name'} eq 'Simple_Version' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Simple Major=\"$cmpreq->{'attributes'}->{'Major'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
        elsif( $cmpreq->{'name'} eq 'Version_Range' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Range LowerMajor=\"$cmpreq->{'attributes'}->{'Lower_Major'}\" LowerMinor=\"$cmpreq->{'attributes'}->{'Lower_Minor'}\" UpperMajor=\"$cmpreq->{'attributes'}->{'Upper_Major'}\" UpperMinor=\"$cmpreq->{'attributes'}->{'Upper_Minor'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
      }
  }
  print OUTFILE "</Dependency>\n";
  print OUTFILE "</BinaryRuntime>\n";
  print OUTFILE "</BinaryDependencies>\n";
}

sub convertSrc
{
  my $args      = shift; 
  my $endtag    = '';
  my $depType   = '';
  my $setuptype = undef;

##  print OUTFILE "<SourceDependencies>\n";
  my $type = $args->{'attributes'}->{'Type'}
      if( defined $args->{'attributes'}->{'Type'} );
  $type = $args->{'attributes'}->{'PkgType'}
      if( defined $args->{'attributes'}->{'PkgType'} );

  for my $pkg (@{$args->{'contents'}}) 
  {
    next if ref($pkg) ne 'HASH';


    if( ($type eq 'data_runtime') or
        ($type eq 'doc_runtime')  or
        ($type eq 'pgm_runtime')  or
        ($type eq 'lib_runtime') )
    {
      print OUTFILE "<SourceDependencies>\n<RuntimeType Type=\"$type\">\n";
      $endtag = '</RuntimeType>';
      $depType = 'Dependency';
    }
    elsif( ($type eq 'data') or
           ($type eq 'doc')  or
           ($type eq 'pgm')  or
           ($type eq 'rtl') )
    {
      $setuptype = $type;
      $type = 'lib' if( $type eq 'rtl' );
      print OUTFILE "<SourceDependencies>\n<SetupType Type=\"$type", "_setup\">\n";
      $endtag = '</SetupType>';
      $depType = 'Dependency';
    }
    elsif( ($type eq 'compile')  or
           ($type eq 'pgm_link') or
           ($type eq 'lib_link') )
    {
      print OUTFILE "<SourceDependencies>\n<BuildType Type=\"$type\">\n";
      $endtag = '</BuildType>';
      $depType = 'BuildDependency';
    }

    foreach my $deps (@{$pkg->{'contents'}})
    {
      next if ref($deps) ne 'HASH';

      my $pkgtype = '';
      $pkgtype = " Package=\"$pkg->{'attributes'}->{'Package'}\" "
          if( defined $pkg->{'attributes'}->{'Package'} );
      $pkgtype = " Package=\"$setuptype\" "
          if( defined $setuptype );
      print OUTFILE "<$depType Name=\"$pkg->{'attributes'}->{'Name'}\" $pkgtype AllowSubstitution=\"No\">\n";

      foreach my $cmpreq (@{$deps->{'contents'}})
      {
        next if ref($cmpreq) ne 'HASH';

        if( $cmpreq->{'name'} eq 'Simple_Version' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Simple Major=\"$cmpreq->{'attributes'}->{'Major'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
        elsif( $cmpreq->{'name'} eq 'Version_Range' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Range LowerMajor=\"$cmpreq->{'attributes'}->{'Lower_Major'}\" LowerMinor=\"$cmpreq->{'attributes'}->{'Lower_Minor'}\" UpperMajor=\"$cmpreq->{'attributes'}->{'Upper_Major'}\" UpperMinor=\"$cmpreq->{'attributes'}->{'Upper_Minor'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
      }
      print OUTFILE "</$depType>\n";
    }
    print OUTFILE "$endtag\n</SourceDependencies>\n";
  }
##  print OUTFILE "</SourceDependencies>\n";
}

sub convertBin
{
  my $args = shift; 
  my $endtag = '';
  my $depType = '';

##  print OUTFILE "<BinaryDependencies>\n";
  my $type = $args->{'attributes'}->{'Type'};

  for my $pkg (@{$args->{'contents'}}) 
  {
    next if ref($pkg) ne 'HASH';


    if( ($type eq 'Regeneration') or
        ($type eq 'Runtime_Link') or
        ($type eq 'Runtime')      or
        ($type eq 'Setup') )
    {
      print OUTFILE "<BinaryDependencies>\n<BinaryRuntime Type=\"$type\">\n";
      $endtag = '</BinaryRuntime>';
      $depType = 'Dependency';
    }
    elsif( ($type eq 'Compile')  or
           ($type eq 'Build_Link') )
    {
      print OUTFILE "<BinaryDependencies>\n<BinaryBuild Type=\"$type\">\n";
      $endtag = '</BinaryBuild>';
      $depType = 'BuildDependency';
    }

    foreach my $deps (@{$pkg->{'contents'}})
    {
      next if ref($deps) ne 'HASH';

      my $pkgtype = '';
      $pkgtype = " Package=\"$pkg->{'attributes'}->{'Package'}\" "
          if( defined $pkg->{'attributes'}->{'Package'} );
      print OUTFILE "<$depType Name=\"$pkg->{'attributes'}->{'Name'}\" $pkgtype AllowSubstitution=\"No\">\n";

      foreach my $cmpreq (@{$deps->{'contents'}})
      {
        next if ref($cmpreq) ne 'HASH';

        if( $cmpreq->{'name'} eq 'Simple_Version' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Simple Major=\"$cmpreq->{'attributes'}->{'Major'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
        elsif( $cmpreq->{'name'} eq 'Version_Range' )
        {
          print OUTFILE "<CompatibilityRequirement>\n";
          print OUTFILE "<Range LowerMajor=\"$cmpreq->{'attributes'}->{'Lower_Major'}\" LowerMinor=\"$cmpreq->{'attributes'}->{'Lower_Minor'}\" UpperMajor=\"$cmpreq->{'attributes'}->{'Upper_Major'}\" UpperMinor=\"$cmpreq->{'attributes'}->{'Upper_Minor'}\"/>\n";
          print OUTFILE "</CompatibilityRequirement>\n";
        }
      }
      print OUTFILE "</$depType>\n";
    }
    print OUTFILE "$endtag\n</BinaryDependencies>\n";
  }
##  print OUTFILE "</BinaryDependencies>\n";
}

=head1 NAME

B<gpt_convert_xml> - Converts original XML package files to the new XML
format. 

=head1 SYNOPSIS

gpt_convert_xml <XML Package Data File Name> 

=head1 DESCRIPTION

B<gpt_convert_xml> will take a GPT version 1.0 or 2.0 XML packaging script
and convert it to the XML format that will be used in future GPT releases. 
I<XML Package Data File Name> is the name of the GPT packaging file that 
will be converted.  This name will also be used in the new GPT XML file
that is created.  The new file will have the form: B<CONV)>I<XML Package Data 
File Name>.

=head1 Description of the Files that B<gpt_convert_xml> Creates

=over 4

=item B<CONV_[XML Package Data]> B<gpt_convert_xml> creates this file from
the contents of the original package data file.  The file will be layed out
using the new XML file lay out as specified by the GPT DTD file. 

=back

=back

=head1 Post B<gpt_convert_xml> Tasks (What is Left to the Developer)

=back

=item B<gpt_convert_xml> does not do everything that is needed in order to
fully convert the XML file.  Some tasks need a developer's touch.  Here is a 
checklist of tasks that may need to be done by hand:

=over 4

=item  B<ContactInfo> needs to be added.  This is a new field used
to hold information on the package creator.  The tags: I<ContactName> and
I<ContactEmail>, should be filled in.

=item B<PackageDocs> needs to be added.  This is a new field used to
hold imformation about documents related to the package.  The tags:
I<PackageDocsDesc> and I<PackageDocsURL> need to be filled in.  The
description should explain what the document is and the URL should hold
the location of the document.

=back

=head1 SEE ALSO

=head1 AUTHOR

Michael Bletzinger E<lt>mbletzin.ncsa.uiuc.eduE<gt> and Eric Blau
E<lt>eblau.ncsa.uiuc.eduE<gt>

=cut
