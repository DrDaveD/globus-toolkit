<html>
<HEAD>
    <title>Globus XIO Architecture</title>
    <style type="text/css">
        <!--
            h3 { background-color: #DCE1FF; background-position: left}
        -->
    </style>
</HEAD>

    <body>
        <CENTER><B><H1>UNDER CONSTRUCTION</H1></B></CENTER>
        <P>
        Read this page at your own risk.  I am adding doc to this as i 
        mold the code.  For the time bieng it will not flow well and will
        look a lot like source code documentation (guess why).
        </P>
        <CENTER><B><H2>State Diagrams</H2></B></CENTER>

        <LI><A HREF="context_state.png">Context</A></LI>
        <LI><A HREF="many_state.png">Others</A></LI>

        <PRE>
        finished op and call stack
        - must be called unlocked
        - callback can be called in same stack (don't need to register oneshot)
            - for drivers and final
        - spaces
            - drivers do not deal in spaces
            - user can register in a space, if they do the final callback is
              registered in a one shot connected to that space
        - register functions cannot call callback
            - so if finished op is called in register function (in other words
              the operation completes before the register function returns)
              xio must detect this and register callback in a oneshot.

        serialized reads and writes.
        - it is possible that a driver stack may want serialized operations.
          In other words that only 1 operation can be registered at a time.
        - this is solved with a driver that serializes
            - this driver can be used anywhere in stack and possibly in 
              multiple places.

        serialized async operations
        - the user handle will have a lock that will be locked around
          serialized requestes
        - the driver, however, will not have this. 
        - in other words, the driver pass function is not thread safe but the
          user register function is thread safe.

        barrier
        - there will be a read EOF barrier and a close barrier
            - this could be handled as a driver but for efficiency reasons
              it will not be.
        - EOF barrier will block the calling of a callback until all 
          outstanding read requests have completed.
        - close barrier 
            - typically when a driver receives a code operation, it cancels
              all outstanding operations.  in this case xio will call 
              the cancel interface function for all outstanding operations
              then when all the callbacks return it will pass the cancel
              down.
            - optionally it can allow outstanding operations to finish
              and then it will close pass the close down to the driver.
            - close callback should return after all outstanding
              callbacks return... but this will just happen due to register
              block.

        error
        - no blocking for errors
        - if an error is returned handle remains open
            - it is possible that later error condition will no longer exist

        driver customize
        - may want to have same driver with differnt global state
            - so you can load the driver once, but intialize its state
              multiple times in different memory locations
        
        cancels
        - how to do this without locks in between drivers

        eof protection may need serialized calls

        close
        - once close is called, it cannot be called again
        - it will clean up all it can
        - this is case if it returns an error or callback comes in with 
          an error or if it succeds 

        cancel
        - happens with close
        - happens with timeouts

        </PRE>
        <BR>
        <PRE>
        Testing Framework
        - echo transport driver
            - simply calls finished op from within the same call stack
        - delayed echo transport driver
            - calls register_one shot to echo finished_op
        - pass though transform driver
            - simply calls pass_op
        - rebuffer transform driver
            - set a new buffer and pass

        - test with file/tcp/gsi also


Roland whispers to you, "right... 'cancel worked' is prolly a bad way to describe it"
"ro" is either ambiguous, or that person isn't here.
Roland whispers to you, "cancel just wakes an operation up and prevents further progress"
You whisper to Roland, "yeah i agree"
Roland whispers to you, "write that down"
        </PRE>
    </body>
</html>
